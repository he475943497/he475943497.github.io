<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>走在启程的路上</title>
  <subtitle>站在巨人的肩膀上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://heweiblog.top/"/>
  <updated>2017-09-01T08:04:29.556Z</updated>
  <id>http://heweiblog.top/</id>
  
  <author>
    <name>贺伟伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux一些命令</title>
    <link href="http://heweiblog.top/2017/09/01/linux%E4%B9%8Bdig%E5%91%BD%E4%BB%A4/"/>
    <id>http://heweiblog.top/2017/09/01/linux之dig命令/</id>
    <published>2017-09-01T07:50:01.000Z</published>
    <updated>2017-09-01T08:04:29.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h2><pre><code>1.查看域名的A记录  dig yahoo.com
2.查看域名的ip  dig yahoo.com +short
3.查看域名的MX 记录  dig yahoo.com MX  
4.查看域名的SOA记录  dig yahoo.com SOA
5.查询域名的TTL记录  dig yahoo.com TTL
6.查看内容信息   dig yahoo.com +nocomments +noquestion +noauthority +noadditional +nostats 
7.查询所有的DNS记录类型  dig yahoo.com ANY +noall +answer 
8.DNS反向查询  dig -x 72.30.38.140 +short 
9.查询多个DNS记录   dig yahoo.com mx +noall +answer redhat.com ns +noall +answer 
10.单独查询    dig yahoo.com A/SOA/MX/NS/PTR +noall +answer    
11.查询所有    dig yahoo.com ANY +noall +answer
12.快速回答时，+short  dig www.baidu.com AAAA +shor
13. +multiline选项获得冗长的多行模式人性化注释的DSN的SOA记录，
    一般来说，用+multiline选项获得的信息可以显示很多，就像BIND配置文件一样
     dig +nocmd baidu.com any +multiline +noall +answer
14.跟踪dig的查询路径    dig v.qq.com +trace
</code></pre><p> 15.dig qq.com @x.x.x.x</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><pre><code>Linux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件
find pathname -options [-print -exec -ok ...]        用于在文件树种查找文件，并作出相应的处理 
find -atime -2     超找48小时内修改过的文件
find . -name &quot;*.log&quot;    在当前目录查找 以.log结尾的文件。 &quot;. &quot;代表当前目录     
find /opt/soft/test/ -perm 777    查找/opt/soft/test/目录下 权限为 777的文件
find . -type f -name &quot;*.log&quot;    查找当目录，以.log结尾的普通文件 
find . -type d | sort    查找当前所有目录并排序
find . -size +1000c -print    查找当前目录大于1K的文件 
ubantu 用于16.04以上版本
</code></pre><h2 id="ubantu-界面设置"><a href="#ubantu-界面设置" class="headerlink" title="ubantu 界面设置"></a>ubantu 界面设置</h2><pre><code>gsettings set com.canonical.Unity.Launcher launcher-position Bottom     移动到下方
gsettings set com.canonical.Unity.Launcher launcher-position Left    移动到左方
</code></pre><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><pre><code>vim打开一个文件 shift + ： 使用 vsplit 命令再打开一个文件    vsplit + 文件 
q qall（关闭所有） only（关闭当前）
在一般模式下输入“:new /root/2.txt” 新编辑文件2.txt
ctrl + ww 切换 

把正在编辑的文件另存为
在一般模式下输入“:w /root/1.txt”

正在编辑文件时，不退出文件仍可以运行linux命令
eg：在编辑模式下输入“:! cat /root/1.txt”

.查找替换的功能使用
例：在10到15行的行首增加“#”
在一般模式下输入“:10,15s/^/#/”
例：在10到15行的行首去掉“#”
在一般模式下输入“:10,15s/^#//”
例：在10到15行的行首增加“//”
在一般模式下输入“:10,15s/^/\/\//”或者“:10,15s@^@//@”或者“:10,15s#^#//#”

把文件恢复到打开时的状态
在一般模式下输入“:e!

vim 中 shift + 3 选中单词 可以突出显示这个单词全部

ctrl +n 自动补全 ctrl + p 也一样

删除空行：:%s/^\n$//g

自动对齐 v 进入可视模式后选中要对齐的部分 = 号自动对齐

stat 文件   获取文件详细信息
fdisk -l 查看磁盘信息

vim 用swap 文件恢复未保存的文件
vim -r filename 后 删除 swap文件
vimdiff 
比较两个文件不同
vimdiff /home/heweiwei/dial_cpp/Makefile Makefile.jc
或者使用diff命令重定向也可以达到比较效果
diff /home/heweiwei/dial_cpp/Makefile Makefile.jc &gt; cmp.txt
</code></pre><h2 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h2><pre><code>查找指定进程
ps -ef|grep svn
ps -aux|grep svn
ps -ef|grep svn -c    包含个数
ps -ef|grep -c svn    

输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行
cat test.txt | grep -f test2.txt
cat test.txt | grep -nf test2.txt

从文件中查找关键字    
grep &apos;linux&apos; test.txt
grep &apos;linux&apos; test.txt test2.txt

grep不显示本身进程
ps aux|grep \[s]sh
ps aux | grep ssh | grep -v &quot;grep&quot;

找出以 u 开头的行内容
cat test.txt |grep ^u
找出非 u 开头的行内容
cat test.txt |grep ^[^u]

输出以hat结尾的行内容
cat test.txt |grep hat$

显示包含ed或者at字符的内容行
cat test.txt |grep -E &quot;ed|at&quot;

显示当前目录下面以.txt 结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行
grep &apos;[a-z]\{7\}&apos; *.txt
</code></pre><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><pre><code>把本地文件或目录拷到目标机指定目录

对拷文件夹 (包括文件夹本身)
scp -r   /home/wwwroot/www/charts/util root@192.168.1.65:/home/wwwroot/limesurvey_back/scp
/home/wwwroot/www/charts/util    本地文件目录
root@192.168.1.65:/home/wwwroot/limesurvey_back/scp    目标ip及目录

对拷文件夹下所有文件 (不包括文件夹本身)
scp   /home/wwwroot/www/charts/util/* root@192.168.1.65:/home/wwwroot/limesurvey_back/scp

 对拷文件并重命名
scp   /home/wwwroot/www/charts/util/a.txt root@192.168.1.65:/home/wwwroot/limesurvey_back/scp/b.text

把目标机文件或者目录拷贝到本地指定目录
scp -r root@192.168.6.240:/home/heweiwei/studytest /home/heweiwei/
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;dig&quot;&gt;&lt;a href=&quot;#dig&quot; class=&quot;headerlink&quot; title=&quot;dig&quot;&gt;&lt;/a&gt;dig&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1.查看域名的A记录  dig yahoo.com
2.查看域名的ip  dig yahoo.com +short

    
    </summary>
    
      <category term="linux命令" scheme="http://heweiblog.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="命令" scheme="http://heweiblog.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>C语言面试</title>
    <link href="http://heweiblog.top/2017/09/01/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95/"/>
    <id>http://heweiblog.top/2017/09/01/C语言面试/</id>
    <published>2017-09-01T07:02:33.000Z</published>
    <updated>2017-09-01T08:06:48.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>曾经面试做过的一些面试题目</p>
<h2 id="C-C-题目："><a href="#C-C-题目：" class="headerlink" title="C/C++题目："></a>C/C++题目：</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h3><p>比较字符串<br>输出它们第一个不同字母的位置，大小写不敏感  // if(str1[i] == (str2[i] | 0x20))<br>int cmpstr(const char<em> str1,const char</em> str2)<br>{<br>    int i = 0;</p>
<pre><code>while(str1[i] != &apos;\0&apos; &amp;&amp; str2[i] != &apos;\0&apos;)
{
    if(str1[i] == (str2[i] | 0x20))
{
    i++;
    continue;
}
return i+1;
}
return 0;
</code></pre><p>}</p>
<h3 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h3><p>判断一个数是不是回文数，数字 1234321。<br>int judge(int num)<br>{<br>    int temp1 = 0,temp2 = 0,temp3 = num;</p>
<pre><code>while(num)
{
    temp1 = num % 10;
temp2 = temp2 * 10 + temp1;
num = num / 10;
}
if(temp2 == temp3)
{
    return 1;
}
return 0;
</code></pre><p>}</p>
<h3 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h3><p>比较两字符串长短，并返回结果。<br>int cmpstr(const char<em> str1,const char</em> str2)<br>{<br>    int i = 0,j = 0;</p>
<pre><code>while(str1[i])
{
    i++;
}

while(str2[j])
{
    j++;
}

return i - j;
</code></pre><p>} </p>
<h3 id="4、给一个字符串，编程取其中一个特定的字符并输出，返回值-int-char-字符的偏移量-或-地址"><a href="#4、给一个字符串，编程取其中一个特定的字符并输出，返回值-int-char-字符的偏移量-或-地址" class="headerlink" title="4、给一个字符串，编程取其中一个特定的字符并输出，返回值 int / char* 字符的偏移量 或 地址"></a>4、给一个字符串，编程取其中一个特定的字符并输出，返回值 int / char* 字符的偏移量 或 地址</h3><p>int findch(const char* str,char ch)<br>{<br>    int i = 0;</p>
<pre><code>while(str[i])
{
    if(ch == str[i])
{
    return i+1;
}
i++;
}
return 0;
</code></pre><p>} </p>
<h3 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h3><p>是比较两个英文字符串的不相同的字符的位置（忽略字母大小写）<br>int cmpstr(const char<em> str1,const char</em> str2,int site[])<br>{<br>    int i = 0,j = 0;</p>
<pre><code>while(str1[i] != &apos;\0&apos; &amp;&amp; str2[i] != &apos;\0&apos;)
{
    if(str1[i] == (str2[i] | 0x20))
{
    i++;
    continue;
}
site[j] = i + 1;
j++;
i++;
}

return j;
</code></pre><p>}</p>
<h3 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h3><p>主函数调用一函数<br>如：检索出字符串中出现次数最多的那个字符，不考虑大小写，然后返回该字符。<br>char findch(const char* str)<br>{<br>    int i = 0,j = 0,ct1 = 0,ct2 = 0;<br>    char ch1 = ‘\0’,ch2 = ‘\0’;</p>
<pre><code>while(str[i])
{
    j = 0;
ct1 = 0;        //这两个条件不可忽略
    while(str[j++])
{
    if(str[i] == str[j])
    {
        ct1++;
    ch1 = str[i];
    }
}
if(ct2 &lt; ct1)
{
    ct2 = ct1;
    ch2 = ch1;
}
i++;
}
return ch2;
</code></pre><p>}</p>
<h3 id="7、"><a href="#7、" class="headerlink" title="7、"></a>7、</h3><p>查找字符串中出现次数最多的字符<br>并返回该字符，只考虑小写字母，不考虑不同字母出现次数一样多的情况<br>char findch(const char* str)<br>{<br>    int i = 0,j = 0,ct1 = 0,ct2 = 0;<br>    char ch1 = ‘\0’,ch2 = ‘\0’;</p>
<pre><code>while(str[i])
{
    if(str[i] &lt; &apos;a&apos; || str[i] &gt; &apos;z&apos;)
{
    i++;
    continue;
}

    j = 0;
ct1 = 0;        //这两个条件不可忽略

    while(str[j++])
{
    if(str[i] == str[j])
    {
        ct1++;
    ch1 = str[i];
    }
}
if(ct2 &lt; ct1)
{
    ct2 = ct1;
    ch2 = ch1;
}
i++;
}
return ch2;
</code></pre><p>}</p>
<h3 id="8、"><a href="#8、" class="headerlink" title="8、"></a>8、</h3><p>输入一个整数n，计算不大于n的数中和7相关的数的个数，<br>包括能被7整出的数和含有字符7的数，例如：输入20，输出3（7、14、17）。<br>int ctseven(int num)<br>{<br>    int ct = 0,i = 0,temp1 = 0,temp2 = 0;</p>
<pre><code>if(num &lt; 7)
{
    return 0;
}

for(i = 7;i &lt; num;i++)
{
    if(i % 7 == 0)
{
    ct++;
    continue;
}

temp2 = i;

    while(temp2)
{
    temp1 = temp2 % 10;
    if(7 == temp1)
    {
        ct++;
        break;
    }
    temp2 = temp2 / 10;
}
}
return ct;
</code></pre><p>}</p>
<h3 id="9、"><a href="#9、" class="headerlink" title="9、"></a>9、</h3><p>输入一个整数将每一位上的奇数放在一个新整数中，高位放在高位，地位在低位。<br>int getnum(int num)<br>{<br>    int i = 1,newnum = 0,temp = 0;    </p>
<pre><code>while(num)
{
    temp = num % 10;
if(temp % 2 != 0)
{
    newnum = newnum + temp * i;
    i *= 10;
}
num = num / 10;
}
return newnum;
</code></pre><p>}</p>
<h3 id="10、"><a href="#10、" class="headerlink" title="10、"></a>10、</h3><p>输入一串数，<br>将其最小的放在第一位，次小的放在最后一位，<br>再小的放在第二位，再再小的放在倒数第二位，以此类推。<br>void get_newnum(int num[],int n)<br>{<br>    int i = 0,j = 0,k = 0,t = 0,temp = 0;    // t k 两个变量均用于控制数组下标</p>
<pre><code>for(i = 0;i &lt; n-1-k;i++)
{
    for(j = i;j &lt; n-1-k;j++)
{
    if(num[i] &gt; num[j+1])
    {
        temp = num[i];
    num[i] = num[j+1];
    num[j+1] = temp;
    }
}
t++;            //算法实现 k控制循环范围 t控制循环数组元素交换    
if(t % 2 == 0)
{
    temp = num[i];
    num[i] = num[n-i];
    num[n-i] = temp;
    i--;
    k++;
}
}
</code></pre><p>}</p>
<h3 id="11、"><a href="#11、" class="headerlink" title="11、"></a>11、</h3><p>写一个函数，传入参数为应付钱数。<br>返回值为买家最少付出的钱的张数int get MoneyNum(int  iInputMoney)例如：买家应付351元，<br>最少张数为5.备注：可支付的钱币只有100、50、10、5、1不考虑2、20以及小数部分。<br>int getct_money(int money)<br>{<br>    int ct = 0;</p>
<pre><code>ct += money / 100;
money %= 100;
ct += money / 50;
money %= 50;
ct += money / 20;
money %= 20;
ct += money / 10;
money %= 10;
ct += money / 5;
money %= 5;
ct += money / 1;
money %= 1;

return ct;
</code></pre><p>}</p>
<h3 id="12、"><a href="#12、" class="headerlink" title="12、"></a>12、</h3><p>设有几个人围坐在一圈并按顺时针方向从1到几编号，从第S个人开始进行1到m的报数。报数到第M个人，此人出圈。再从他的下一个人重新开始1到M的报数，如此进行下一直到所有人都出圈为止，输出报数顺序。<br>void getrank(int num[],int n,int num1,int num2,int newnum[])<br>{<br>    struct rank<br>    {<br>        int number;<br>    struct rank<em> next;<br>    };<br>    int i = 0,j = 0;<br>    struct rank</em> p = NULL;<br>    struct rank<em> temp1 = NULL;<br>    struct rank</em> temp2 = NULL;<br>    struct rank* phead = NULL;</p>
<pre><code>phead = p = calloc(1,sizeof(struct rank));
p-&gt;number = num[0];

for(i = 1;i &lt; n;i++)
{
    p-&gt;next = calloc(1,sizeof(struct rank));
    p-&gt;next-&gt;number = num[i];
p = p-&gt;next;
}

p-&gt;next = phead;            //形成一个环形链表

while(phead-&gt;number != num1)    //找出从谁开始报数
{
phead = phead-&gt;next;
}

for(j = 0;j &lt; n;j++)            
{
    for(i = 0;i &lt; num2-1;i++)    //报数到num2时跳出循环 phead指向的number就是要出圈的数字
    {
    temp1 = phead;
    phead = phead-&gt;next;
    }
newnum[j] = phead-&gt;number;
temp2 = phead;
phead = phead-&gt;next;
free(temp2);            //出圈后删除该节点
temp1-&gt;next = phead;     
}
</code></pre><p>}</p>
<h3 id="13、"><a href="#13、" class="headerlink" title="13、"></a>13、</h3><p>对姓氏进行排名<br>Char str[ ]=”zhang   wang   li    zhao”<br>Char str_ new[ ]=”li  wang   zhang   zhao”<br>void getstr(char str1[],int n,char str2[])<br>{<br>    int i = 0,j = 0,k = 0;    //i j k 均用于数组下标<br>    int len = strlen(str1);<br>    char<em> str[n];<br>    char</em> temp = NULL;</p>
<pre><code>for(i = 0;i &lt; n;i++)
{
    str[i] = calloc(1,len);
}

i = 0;        //while 一定要初始化
while(str1[i])    //str[i++] 不可这样写
{
    if(str1[i] == &apos; &apos;)
{
    k = 0;
    j++;
    i++;    //while continue前 i++    
    continue;
}
str[j][k] = str1[i];
i++;
k++;
}

for(i = 0;i &lt; n-1;i++)
{
    for(j = i;j &lt; n-1;j++)
{
    if(strcmp(str[i],str[j+1]) &gt; 0)
    {
        temp = str[i];
    str[i] = str[j+1];
    str[j+1] = temp;
    }
}
}

strcpy(str2,str[0]);

for(i = 1;i &lt; n;i++)
{
    strcat(str2,&quot; &quot;);
    strcat(str2,str[i]);
}

for(i = 0;i &lt; n;i++)
{
    free(str[i]);
}
</code></pre><p>}</p>
<h3 id="14、"><a href="#14、" class="headerlink" title="14、"></a>14、</h3><p>将一组整数中为奇数的数提取出来，高低位顺序不变。如：8 3 7 9 5 2 1 4—–》3 7 5 1<br>int getodd(int num1[],int n,int num2[])<br>{<br>    int i = 0,j = 0;</p>
<pre><code>for(i = 0;i &lt; n;i++)
{
    if(num1[i] % 2 != 0)
{
    num2[j] = num1[i];
    j++;
}
}
return j;
</code></pre><p>}</p>
<h3 id="15、"><a href="#15、" class="headerlink" title="15、"></a>15、</h3><p>一组2n+1个元素的正整形数组，按升序排序，然后将小于中间数值的成员替换为中间的值。（貌似还有：“位置不变”，不过实在不理解其含义，看了例子就不用关心它的意思了），例如：1,2,3,4,5，输出为：3,3,3,4,5，原型：int fun(int arry[],int n,char<em>output){return 0;}<br>int fun(int num[],int n,char</em> output)<br>{<br>    int i = 0,j = 0,temp = 0;</p>
<pre><code>for(i = 0;i &lt; n-1;i++)
{
    for(j = i;j &lt; n-1;j++)
{
    if(num[i] &gt; num[j+1])
    {
        temp = num[i];
    num[i] = num[j+1];
    num[j+1] = temp;
    }
}
}

j = n / 2;

for(i = 0;i &lt; j;i++)
{
    num[i] = num[j];
}

for(i = 0;i &lt; n;i++)
{
    output[i] = num[i] + &apos;0&apos;;
}

return num[j];
</code></pre><p>}</p>
<h3 id="16、"><a href="#16、" class="headerlink" title="16、"></a>16、</h3><p>输入一个四位的十进制整数，编程实现将这四位整数转化为十六进制的字符串，并输出十六进制的字符串（注意负数的处理）<br>int hex_to_str(int num,char str[])<br>{<br>    int i = 0,len = 0,temp = 0;<br>    char ch = ‘\0’;</p>
<pre><code>while(num)
{
temp = num &amp; 0xf;

    if(temp &lt; 10)
{
    str[i] = &apos;0&apos; + temp;
}
else
{
    str[i] = &apos;a&apos; + temp - 10;
} 

num = num &gt;&gt; 4;

if(num &lt; 0)
{
    num = num &amp; 0xfffffff;
}
i++;
}

str[i] = &apos;\0&apos;;
len = strlen(str);

for(i = 0;i &lt; len / 2;i++)
{
    ch = str[i];
str[i] = str[len-1-i];
str[len-1-i] = ch;
}

return len;
</code></pre><p>}</p>
<h3 id="17、输入：一个四位的整数，比如：2367，输出：2-3-6-7-18"><a href="#17、输入：一个四位的整数，比如：2367，输出：2-3-6-7-18" class="headerlink" title="17、输入：一个四位的整数，比如：2367，输出：2+3+6+7=18"></a>17、输入：一个四位的整数，比如：2367，输出：2+3+6+7=18</h3><p>int int_to_str(int num,char str[])<br>{<br>    int i = 0,j = 0,k = 0,temp = num,sum = 0;</p>
<pre><code>while(temp)
{
    temp /= 10;
i++;
}

int* pnum = calloc(i+1,sizeof(int));
for(j = i-1;j &gt;= 0;j--)
{
    pnum[j] = num % 10;
sum += pnum[j];
num = num / 10;
}
pnum[i] = sum;

for(j = 0;j &lt; i*2;j++)
{
    if(j % 2 == 0)
{
        str[j] = pnum[k] + &apos;0&apos;;
    k++;
    continue;
} 
str[j] = &apos;+&apos;;
}

j--;
str[j] = &apos;=&apos;;

if(sum / 10)
{
    str[j+1] = sum / 10 + &apos;0&apos;;        
    str[j+2] = sum % 10 + &apos;0&apos;;
str[j+3] = &apos;\0&apos;
free(pnum);
return j+3;
}

str[j+1] = &apos;0&apos; + sum % 10;
str[j+2] = &apos;\0&apos;
free(pnum);
return j+2;
</code></pre><p>}</p>
<h3 id="18-将一个正整数转换为字符串"><a href="#18-将一个正整数转换为字符串" class="headerlink" title="18,将一个正整数转换为字符串"></a>18,将一个正整数转换为字符串</h3><p>char<em> int_to_str(int num,char</em> str)<br>{<br>    int i = 0,j = 0,temp1 = 0,temp2 = num;</p>
<pre><code>while(num)
{
    temp1 = num % 10;          
    num = num / 10;
j++;
}
str[j] = &apos;\0&apos;;
for(i = j-1;i &gt;= 0;i--)
{
temp1 = temp2 % 10;
str[i] = &apos;0&apos; + temp1;
temp2 = temp2 / 10;
}
return str;
</code></pre><p>}</p>
<h3 id="19，"><a href="#19，" class="headerlink" title="19，"></a>19，</h3><p>将一个字符串转换为正整数<br>int str_to_int(const char* str)<br>{<br>    int i = 0,sum = 0;</p>
<pre><code>while(str[i])
{
    sum = sum * 10 + (str[i] - &apos;0&apos;);
i++;
}
return sum;
</code></pre><p>}</p>
<h3 id="20-从长串中找到连续相同字符最长的字串"><a href="#20-从长串中找到连续相同字符最长的字串" class="headerlink" title="20,从长串中找到连续相同字符最长的字串"></a>20,从长串中找到连续相同字符最长的字串</h3><p>int get_childstr(const char<em> str,char</em> childstr)<br>{<br>    int i = 0,ct1 = 0,ct2 = 0;<br>    char ch = ‘\0’;</p>
<pre><code>while(str[i])
{
    ct1 = &apos;\0&apos;;            // 要比较 切莫忘记初始化比较量
    while(str[i] == str[i+1])
{
    ct1++;
    i++;
}
if(ct2 &lt; ct1)
{
    ct2 = ct1;
    ch = str[i];
}
i++;
}
for(i = 0;i &lt; ct2+1;i++)
{
    childstr[i] = ch;
}
childstr[i] = &apos;\0&apos;;

return ct2+1;
</code></pre><p>}</p>
<h3 id="21"><a href="#21" class="headerlink" title="21,"></a>21,</h3><p>将一个字符串逆序<br>char* getstr(char str[])<br>{<br>    int i = 0;<br>    int len = strlen(str);<br>    char ch = ‘\0’;</p>
<pre><code>for(i = 0;i &lt; len / 2;i++)
{
ch = str[i];
str[i] = str[len-i-1];
str[len-i-1] = ch;
}
return str;
</code></pre><p>}</p>
<h3 id="22"><a href="#22" class="headerlink" title="22,"></a>22,</h3><p>搜索给定的字节<br>void<em> findbyte(const void</em> st,size_t len,char dat)<br>{<br>    int i = 0;<br>    char<em> str = (char</em>)st;</p>
<pre><code>while(str[i])
{
if(dat == str[i])
{
    return str + i;
}
i++;
}

return NULL;
</code></pre><p>}</p>
<h3 id="23-将一个链表逆序"><a href="#23-将一个链表逆序" class="headerlink" title="23,将一个链表逆序"></a>23,将一个链表逆序</h3><p>void oppsite_list(ST<em> head)<br>{<br>    ST</em> phead = NULL;<br>    ST* P = head;<br>    head = head-&gt;next;<br>    p-&gt;next = NULL;</p>
<pre><code>while(head)        //    循环结束后 p 变为头指针
{
    phead = head-&gt;next
head-&gt;next = p;
p = head;        
head = phead;
}
</code></pre><p>}</p>
<h3 id="24"><a href="#24" class="headerlink" title="24,"></a>24,</h3><p>判断一个字节有多少个1<br>int getsize(char ch)<br>{<br>    int i = 8,temp = 0,ct = 0;<br>    while(i–)<br>    {<br>    temp = ch &amp; 1;<br>    if(temp)<br>    {<br>        ct++;<br>    }<br>    ch &gt;&gt;= 1;<br>    }<br>    return ct;<br>}</p>
<h3 id="24-1"><a href="#24-1" class="headerlink" title="24,"></a>24,</h3><p>直接插入排序 冒泡排序 选择排序<br>void rank(int num[],int n)    // 直接插入<br>{<br>    int i = 0,j = 0,temp = 0;</p>
<pre><code>for(i = 1;i &lt; n;i++)
{
    temp = num[i];
for(j = i - 1;j &gt;= 0 &amp;&amp; temp &lt; num[j];j--)    // temp&lt;num[j]从小到大  temp&gt;num[j]从大到小 
{
    num[j+1] = num[j];
}
num[j+1] = temp;
}
</code></pre><p>}</p>
<p>void rank(int num[],int n)    // 冒泡<br>{<br>    int i = 0,j = 0,temp = 0;</p>
<pre><code>for(i = 0;i &lt; n;i++)
{
for(j = n - 1;j &gt;= i;j--)     
{
    if(num[j+1] &lt; num[j])
    {
    temp = num[j+1];
    num[j+1] = num[j];
    num[i] = temp;
    }
}
}
</code></pre><p>}</p>
<p>void myrank_min(int num[],int count)    // 冒泡<br>{<br>    int i = 0,j = 0,temp = 0;</p>
<pre><code>for(i = 0;i &lt; count-1;i++)
{
for(j = i;j &lt; count-1;j++)
{
    if(num[i] &gt; num[j+1])
    {
        temp = num[i];
    num[i] = num[j+1];
    num[j+1] = temp;
    }
}
}
</code></pre><p>}</p>
<p>void rank(int num[],int n)    // 选择<br>{<br>    int i = 0,j = 0,k = 0,temp = 0;</p>
<pre><code>for(i = 0;i &lt; n;i++)
{
temp = num[i];
k = i;
for(j = i;j &lt; n;j++)     
{
    if(temp &gt; num[j])
    {
    temp = num[j];
    k = j;
    }
}
num[k] = num[i];
num[i] = temp;
}
</code></pre><p>}</p>
<h3 id="26"><a href="#26" class="headerlink" title="26,"></a>26,</h3><p>判断一个字符串有多少个单词<br>int getsize(const char* str)<br>{<br>    int state = 0,i = 0,ct = 0;</p>
<pre><code>while(str[i])
{
if(str[i] == &apos; &apos;)
{
    state = 1;
    i++;
    continue;
}
if(state)
{
    state = 0;
    ct++;
}
}
return ct+1;
</code></pre><p>}</p>
<p>###26,<br>实现strcmp<br>int strcmp(onst char<em> s1,const char</em> s2)<br>{<br>    int i = 0;</p>
<pre><code>while(s1[i] != &apos;\0&apos; &amp;&amp; s2[i] != &apos;\0&apos;)
{
    if(s1[i] == s2[i])
{
    i++;
    continue;
}
return s1[i] - s2[i];
}
if(strlen(s1) == strlen(s2))
{
return 0;
}
return strlen(s1) - strlen(s2);
</code></pre><p>}</p>
<p>int strcmp(onst char<em> s1,const char</em> s2)<br>{<br>    int i = 0;</p>
<pre><code>while(s1[i] != &apos;\0&apos; &amp;&amp; s2[i] != &apos;\0&apos;)
{
    if(s1[i] == s2[i])
{
    i++;
    continue;
}
return s1[i] - s2[i];
}
if(s1[i] == &apos;\0&apos;)
{
return -1;
}
if(s2[i] == &apos;\0&apos;)
{
    return 1;
}
return 0;
</code></pre><p>}</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面试还是看基础</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;曾经面试做过的一些面试题目&lt;/p&gt;
&lt;h2 id=&quot;C-C-题目：&quot;&gt;&lt;a href=&quot;#C-C-题目：&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="C语言" scheme="http://heweiblog.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C面试" scheme="http://heweiblog.top/tags/C%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>有趣的C语言小测试</title>
    <link href="http://heweiblog.top/2017/09/01/%E6%9C%89%E8%B6%A3%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%B5%8B%E8%AF%95/"/>
    <id>http://heweiblog.top/2017/09/01/有趣的C语言小测试/</id>
    <published>2017-09-01T06:07:31.000Z</published>
    <updated>2017-09-01T06:42:58.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>C语言是其他语言拓展的基石，如对库的支撑，C语言暂时不敢变，变了岂不好多人要失业，高级语言可以玩出很多变化，但是偏底层靠的是基础，俗话说万变不离其宗，基础扎实才是拓展的前提。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>下面各个题目输出是什么呢？32位操作系统</p>
<h3 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h3><p>unsigned int a = 6;<br>int b = -20;<br>(a+b &gt; 0)? puts(“why”) : puts(“I don‘t no”);</p>
<h3 id="测试二"><a href="#测试二" class="headerlink" title="测试二"></a>测试二</h3><p>int ar[] ={6,7,8,9,10};<br>int <em>ptr=ar;
</em>(ptr++)+=123;<br>printf(“%d,%d \n”,<em>ptr,</em>(++ptr));<br>printf(“%d%d%d\n”,ar[0],ar[1],ar[2]);</p>
<h3 id="测试三"><a href="#测试三" class="headerlink" title="测试三"></a>测试三</h3><p>int a[3] = {1,11,22};<br>int <em>p = a;<br>printf(“</em>p++ = %d\n”,<em>p++);<br>printf(“</em>++p = %d\n”,*++p);</p>
<h3 id="测试四"><a href="#测试四" class="headerlink" title="测试四"></a>测试四</h3><p>int a[5] = { 1 , 2 , 3 , 4 , 5 };<br>int <em>ptr = (int </em>)( (char<em>) a + 1 );<br>printf(“%#x\n”,</em>ptr);    </p>
<h3 id="测试五"><a href="#测试五" class="headerlink" title="测试五"></a>测试五</h3><p>求一个字符串长度，不要用库函数，不要用中间变量</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="测试一-1"><a href="#测试一-1" class="headerlink" title="测试一"></a>测试一</h3><p>无符号整型问题的答案是输出是“why”。<br>原因是当表达式中存在有符号<br>类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大<br>的正整数，所以该表达式计算出的结果大于0。</p>
<h3 id="测试二-1"><a href="#测试二-1" class="headerlink" title="测试二"></a>测试二</h3><p>输出依次是 8  8  129  7  8<br>拆开后看是这样的<br><em>ptr += 123；<br>ptr++；<br>++ptr；<br>printf(“%d,%d \n”,</em>ptr,*ptr);<br>printf(“%d%d%d\n”,ar[0],ar[1],ar[2]);</p>
<h3 id="测试三-1"><a href="#测试三-1" class="headerlink" title="测试三"></a>测试三</h3><p>输出为1 22<br>计算顺序<br>printf(“<em>p++ = %d\n”,</em>p);<br>p++;<br>++p;<br>printf(“<em>++p = %d\n”,</em>p);</p>
<h3 id="测试四-1"><a href="#测试四-1" class="headerlink" title="测试四"></a>测试四</h3><p>结果 0x2000000<br>数据在内存的储存形式</p>
<h3 id="测试五-1"><a href="#测试五-1" class="headerlink" title="测试五"></a>测试五</h3><p>可以用递归<br>int getlen(char<em>s)<br>{<br>    if(</em>s == ‘\0’)<br>        return 0;<br>    s++;<br>    return getlen(s) + 1;<br>}</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不要小看一些细小的额东西，有些错误很难发现有可能就是因为这些越细小的基础造成的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;C语言是其他语言拓展的基石，如对库的支撑，C语言暂时不敢变，变了岂不好多人要失业，高级语言可以玩出很多变化，但是偏底层靠的是基础，俗话说万变
    
    </summary>
    
      <category term="C语言" scheme="http://heweiblog.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C基础" scheme="http://heweiblog.top/tags/C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>git远程仓库关联</title>
    <link href="http://heweiblog.top/2017/09/01/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94/"/>
    <id>http://heweiblog.top/2017/09/01/git远程仓库关联/</id>
    <published>2017-09-01T04:51:18.000Z</published>
    <updated>2017-09-01T05:50:01.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我的环境：ubantu17.04 其他linux发行版本安装使用大同小异<br>安装git：sudo apt-get install git<br>首先必须有一个githup账号 去官网注册即可 同时绑定邮箱<br>有了账号后创建远程仓库 比如我创建的仓库名字为project</p>
<h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>本地创建密钥命令如下<br>ssh-keygen -t rsa -C “邮箱地址”<br>公钥存放在用户主目录 ~/.ssh/id_rsa.pub<br>复制到官网在账户设置一栏添加即可</p>
<h2 id="验证连接"><a href="#验证连接" class="headerlink" title="验证连接"></a>验证连接</h2><p>验证是否能连接上<br>ssh -T git@github.com<br>输入yes后出现类似以下内容表示已经可以连接<br>Hi he475943497! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<h2 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h2><p>执行下列命令<br>创建仓库并初始化<br>mkdir project<br>cd project<br>git init</p>
<h2 id="指明用户"><a href="#指明用户" class="headerlink" title="指明用户"></a>指明用户</h2><p>若之前没有使用git执行以下操作<br>git config –global user.email “邮箱地址”<br>git config –global user.name “用户名”</p>
<h2 id="本地与远程关联并推送"><a href="#本地与远程关联并推送" class="headerlink" title="本地与远程关联并推送"></a>本地与远程关联并推送</h2><p>touch test.txt<br>git add test.txt<br>git commit -m “test”<br>git remote add origin git@github.com:用户名/仓库名.git<br>推送到远程<br>git push -u origin master 第一次提交加-u参数<br>之后提交<br>git add .  git commit -m “test”   git push 即可</p>
<h2 id="git教程"><a href="#git教程" class="headerlink" title="git教程"></a>git教程</h2><p>git作为目前最流行的版本管理工具，我觉得很有学习的必要<br>有兴趣的同学可以参考：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰git教程</a><br>作者写的很幽默通俗易懂</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我的环境：ubantu17.04 其他linux发行版本安装使用大同小异&lt;br&gt;安装git：sudo apt-get install git
    
    </summary>
    
      <category term="开发工具" scheme="http://heweiblog.top/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://heweiblog.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>你好世界</title>
    <link href="http://heweiblog.top/2017/08/31/hello-world/"/>
    <id>http://heweiblog.top/2017/08/31/hello-world/</id>
    <published>2017-08-31T09:36:50.874Z</published>
    <updated>2017-08-31T09:36:50.874Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来的 <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a> 的世界! 这是你的第一个帖子.仔细检查一下 <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> 更多信息。如果你在使用Hexo上遇到任何问题，你可以找到答案 <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> 或者你可以询问 <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建第一个帖子"><a href="#创建第一个帖子" class="headerlink" title="创建第一个帖子"></a>创建第一个帖子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎来的 &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt; 的世界! 这是你的第一个帖子.仔细检查一下 &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; 更多信息。如果你在使用Hexo上遇到任何问题，你可以找到答案 &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; 或者你可以询问 &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="http://heweiblog.top/2017/08/31/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://heweiblog.top/2017/08/31/hexo搭建个人博客/</id>
    <published>2017-08-31T02:46:56.000Z</published>
    <updated>2017-09-01T05:46:18.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>想拥有一个个人博客，利用hexo可以满足基本需求，博客应有的基本功能都可以实现</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>ubantu mac windows 均可</p>
<h2 id="必备"><a href="#必备" class="headerlink" title="必备"></a>必备</h2><p>git  nodejs  npm  nvm  具体怎么安装百度一下即可方法很多</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>所关联github上个人仓库必须和用户名相同 如用户名为heweiwei 则仓库名应该为heweiwei.github.io</p>
<h2 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h2><p>解决 vimrc添加一下内容<br>set fileencodings=utf-8,gb2312,gbk,gb18030<br>set termencoding=utf-8<br>set encoding=prc</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>前面各个必备软件安装正常<br>执行 npm install -g hexo-cli </p>
<h3 id="推送到远程"><a href="#推送到远程" class="headerlink" title="推送到远程"></a>推送到远程</h3><p>hexo init hexoweb<br>cd hexoweb/<br>npm install<br>hexo clean<br>hexo new your post name<br>hexo generate<br>hexo deploy<br>当然这样做之后访问的页面很简单具体修改参见:<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo官方文档</a></p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>浏览器输入yourname.github.io即可访问<br>也可以去域名服务商买一个域名<br>价格不等我买的.top顶级域第一年8块大洋</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>我用的是next主题简单大体参照<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="external">next官方使用文档</a>就够了<br>更换背景：<br>找一个背景图片放到 hexo（hexo工程文件）themes/next/source/images 下<br>修改themes/next/source/css/_custom/custom.styl文件<br>在文件加上一代码<br> body { background:url(/images/yourbackGround.jpg);} </p>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>外观设计基本搞定之后剩下的就是苦力活了<br>参照<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">hexo官方文档</a>基本都能搞定</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;想拥有一个个人博客，利用hexo可以满足基本需求，博客应有的基本功能都可以实现&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; 
    
    </summary>
    
      <category term="搭建博客" scheme="http://heweiblog.top/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://heweiblog.top/tags/hexo/"/>
    
      <category term="博客" scheme="http://heweiblog.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
