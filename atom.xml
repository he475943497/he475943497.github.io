<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>走在启程的路上</title>
  <subtitle>站在巨人的肩膀上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://heweiblog.top/"/>
  <updated>2017-09-14T11:39:05.939Z</updated>
  <id>http://heweiblog.top/</id>
  
  <author>
    <name>贺伟伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux内核之list.h</title>
    <link href="http://heweiblog.top/2017/09/14/linux%E5%86%85%E6%A0%B8%E4%B9%8Blist-h/"/>
    <id>http://heweiblog.top/2017/09/14/linux内核之list-h/</id>
    <published>2017-09-14T11:28:08.000Z</published>
    <updated>2017-09-14T11:39:05.939Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p><a href="http://www.linuxidc.com/Linux/2011-10/44627.htm" target="_blank" rel="external">大而全参考地址</a><br>非常详细</p>
<h2 id="内核中经常采用链表来管理对象，先看一下内核中对链表的定义"><a href="#内核中经常采用链表来管理对象，先看一下内核中对链表的定义" class="headerlink" title="内核中经常采用链表来管理对象，先看一下内核中对链表的定义"></a>内核中经常采用链表来管理对象，先看一下内核中对链表的定义</h2><p>struct list_head {<br>    struct list_head <em>next, </em>prev;<br>};</p>
<p>一般将该数据结构嵌入到其他的数据结构中，从而使得内核可以通过链表的方式管理新的数据结构，看一个例子:<br>struct example {<br>    member a;<br>    struct list_head list;<br>    member b;<br>};</p>
<h2 id="1、链表的定义和初始化"><a href="#1、链表的定义和初始化" class="headerlink" title="1、链表的定义和初始化"></a>1、链表的定义和初始化</h2><p>您可以通过两种方式来定义和初始化一个链表头结点，例如，您想定义一个链表头结点mylist，那么您可以这么做：<br>① LIST_HEAD(mylist);  // 使用LIST_HEAD宏定义并初始化一个链表<br>也可以这么做：<br>② struct list_head mylist;  // 定义一个链表<br>INIT_LIST_HEAD(&amp;mylist); // 使用INIT_LIST_HEAD函数初始化链表</p>
<p>可以看出方式①稍微简单一点，我们先来分析一下LIST_HEAD宏：</p>
<p>#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }</p>
<p>#define LIST_HEAD(name) /<br>struct list_head name = LIST_HEAD_INIT(name)</p>
<p>很容易看出LIST_HEAD(mylist);会被扩展为：<br>struct list_head mylist = { &amp;(mylist), &amp;(mylist) };</p>
<p>list_head结构只有两个成员：next和prev。从上面的代码可以看出，next和prev都被赋值为链表mylist的地址，也就是说，链表初始<br>化后next和prev都是指向自己的。</p>
<p>大多数情况下，list_head是被嵌入到其他数据结构中的，比如上面的example结构里的list成员，那么如何对list成员进行初始化？通过调用INIT_LIST_HEAD函数：<br>struct example test;<br>INIT_LIST_HEAD(&amp;test.list);<br>该函数简单地将list成员的prev和next指针指向自己。</p>
<p>可以看出链表结点在初始化时，都将prev和next指向自己。注意：对链表的初始化非常重要，因为如果使用一个未被初始化的链表结点，很有可能会导致内核异常。例如，在对一个链表结点调用list_del函数后，接着再去对该结点进行一些操作。后面会有分析的：）</p>
<h2 id="2、对链表常用的操作"><a href="#2、对链表常用的操作" class="headerlink" title="2、对链表常用的操作"></a>2、对链表常用的操作</h2><p>对链表常用的操作无非就是增加、删除、遍历等。当然内核还提供很多其他的操作，如替换某个结点、将某个结点移动到链表尾端等等，这些操作都是通过调用基本的增加、删除等操作完成的。</p>
<h3 id="①-增加：list-add和list-add-tail"><a href="#①-增加：list-add和list-add-tail" class="headerlink" title="① 增加：list_add和list_add_tail"></a>① 增加：list_add和list_add_tail</h3><p>调用list_add可以将一个新链表结点插入到一个已知结点的后面；<br>调用list_add_tail可以将一个新链表结点插入到一个已知结点的前面；</p>
<p>下面分析它们的具体实现，它们都以不同的参数调用了相同的函数<strong>list_add：<br>static inline void </strong>list_add(struct list_head <em>new,<br>        struct list_head </em>prev,<br>        struct list_head *next)<br>{<br>    next-&gt;prev = new;<br>    new-&gt;next = next;<br>    new-&gt;prev = prev;<br>    prev-&gt;next = new;<br>}<br>该函数将new结点插入到prev结点和next之间；</p>
<p>static inline void list_add(struct list_head <em>new, struct list_head </em>head)<br>{<br>    <strong>list_add(new, head, head-&gt;next);<br>}<br>list_add函数中以new、head、head-&gt;next为参数调用</strong>list_add，将new结点插入到head和head-&gt;next之间，也就是将new结点插入到特定的已知结点head的后面；</p>
<p>static inline void list_add_tail(struct list_head <em>new, struct list_head </em>head)<br>{<br>    <strong>list_add(new, head-&gt;prev, head);<br>}<br>而list_add_tail函数则以new、head-&gt;prev、head为参数调用</strong>list_add，将new结点插入到head-&gt;prev和head之间，也就是将new结点插入到特定的已知结点head的前面。</p>
<p>有了list_add和list_add_tail，我们可以很方便地实现栈（list_add）和队列（list_add_tail），在本文的最后一节，我们再做详细的分析。</p>
<h3 id="②-删除：list-del和list-del-init"><a href="#②-删除：list-del和list-del-init" class="headerlink" title="② 删除：list_del和list_del_init"></a>② 删除：list_del和list_del_init</h3><p>调用list_del函数删除链表中的一个结点；<br>调用list_del_init函数删除链表中的一个结点，并初始化被删除的结点（也就是使被删除的结点的prev和next都指向自己）；</p>
<p>下面分析它们的具体实现，它们都调用了相同的函数<strong>list_del：<br>static inline void </strong>list_del(struct list_head <em> prev, struct list_head </em> next)<br>{<br>    next-&gt;prev = prev;<br>    prev-&gt;next = next;<br>}<br>该函数实际的作用是让prev结点和next结点互相指向；</p>
<p>static inline void list_del(struct list_head *entry)<br>{<br>    <strong>list_del(entry-&gt;prev, entry-&gt;next);<br>    entry-&gt;next = LIST_POISON1;<br>    entry-&gt;prev = LIST_POISON2;<br>}<br>该函数中以entry-&gt;prev和entry-&gt;next为参数调用</strong>list_del函数，使得entry结点的前、后结点绕过entry直接互相指向，然后将entry结点的前后指针指向LIST_POISON1和LIST_POISON2，从而完成对entry结点的删除。此函数中的LIST_POISON1和LIST_POISON2有点让人费解，因为一般情况下我们删除entry后，应该让entry的prev和next指向NULL的，可是这里却不是，原因有待调查。</p>
<p>static inline void list_del_init(struct list_head *entry)<br>{<br>    __list_del(entry-&gt;prev, entry-&gt;next);<br>    INIT_LIST_HEAD(entry);<br>}<br>与list_del不同，list_del_init将entry结点删除后，还会对entry结点做初始化，使得entry结点的prev和next都指向自己。</p>
<h2 id="3、几个重要的宏"><a href="#3、几个重要的宏" class="headerlink" title="3、几个重要的宏"></a>3、几个重要的宏</h2><p>内核提供了一组宏，以方便对链表进行管理，下面我只介绍到目前为止，我遇到过的，可能会很少，因为我接触到的很有限，以后遇到其他的会添加进来的。下面开始我们的分析啦:)</p>
<h3 id="①-list-entry"><a href="#①-list-entry" class="headerlink" title="① list_entry"></a>① list_entry</h3><p>前面说过，list_head结构通常被嵌入到其他数据结构中，以便内核可以通过链表的方式管理这些数据结构。假设这样一种场景：我们已知类型为example的对象的list成员的地址ptr（struct list_head *ptr），那么我们如何通过ptr来得到该example对象的地址呢？答案很明显，使用container_of宏。不过，在这样的情况下我们应该通过使用list_entry宏来完成container_of宏的功能，因为这样更容易理解一点。其实list_entry宏很简单：#define list_entry(ptr, type, member)  container_of(ptr, type, member) ……<br>上述情况，我们可以这样： list_entry(ptr, struct example, list); 来获取example对象的指针。</p>
<h3 id="②-list-for-each-entry"><a href="#②-list-for-each-entry" class="headerlink" title="② list_for_each_entry"></a>② list_for_each_entry</h3><p>对链表的一个重要的操作就是对链表进行遍历，以达到某种应用目的，比如统计链表结点的个数等等。先来看看内核中对该宏的定义：</p>
<p>#define list_for_each_entry(pos, head, member)    /<br>for (pos = list_entry((head)-&gt;next, typeof(<em>pos), member); /<br>        prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);  /<br>        pos = list_entry(pos-&gt;member.next, typeof(</em>pos), member))</p>
<p>其中，pos是指向宿主结构的指针，在for循环中是一个迭代变量；head是要进行遍历的链表头指针；member是list_head成员在宿主结构中的名字。</p>
]]></content>
    
    <summary type="html">
    
      linux内核提供了一套完整简单实用的链表操作方法，非常值得值得学习，极具可移植可拓展
    
    </summary>
    
      <category term="linux基础" scheme="http://heweiblog.top/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="list" scheme="http://heweiblog.top/tags/list/"/>
    
      <category term="linux基础" scheme="http://heweiblog.top/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="链表基础操作" scheme="http://heweiblog.top/tags/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>linux压缩命令</title>
    <link href="http://heweiblog.top/2017/09/12/linux%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/"/>
    <id>http://heweiblog.top/2017/09/12/linux压缩命令/</id>
    <published>2017-09-12T01:41:44.000Z</published>
    <updated>2017-09-12T01:50:47.410Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>[root@www ~]# tar [-j|-z] [cv] [-f 创建的档名] filename… &lt;==打包与压缩<br>[root@www ~]# tar [-j|-z] [tv] [-f 创建的档名]             &lt;==察看档名<br>[root@www ~]# tar [-j|-z] [xv] [-f 创建的档名] [-C 目录]   &lt;==解压缩</p>
<h2 id="选项与参数："><a href="#选项与参数：" class="headerlink" title="选项与参数："></a>选项与参数：</h2><p>-c  ：创建打包文件，可搭配 -v 来察看过程中被打包的档名(filename)<br>-t  ：察看打包文件的内容含有哪些档名，重点在察看『档名』就是了；<br>-x  ：解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开<br>      特别留意的是， -c, -t, -x 不可同时出现在一串命令列中。<br>-j  ：透过 bzip2 的支持进行压缩/解压缩：此时档名最好为 <em>.tar.bz2<br>-z  ：透过 gzip  的支持进行压缩/解压缩：此时档名最好为 </em>.tar.gz<br>-v  ：在压缩/解压缩的过程中，将正在处理的档名显示出来！<br>-f filename：-f 后面要立刻接要被处理的档名！建议 -f 单独写一个选项罗！<br>-C 目录    ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</p>
<h2 id="其他后续练习会使用到的选项介绍："><a href="#其他后续练习会使用到的选项介绍：" class="headerlink" title="其他后续练习会使用到的选项介绍："></a>其他后续练习会使用到的选项介绍：</h2><p>-p  ：保留备份数据的原本权限与属性，常用於备份(-c)重要的配置档<br>-P  ：保留绝对路径，亦即允许备份数据中含有根目录存在之意；<br>–exclude=FILE：在压缩的过程中，不要将 FILE 打包！ </p>
<h2 id="其实最简单的使用-tar-就只要记忆底下的方式即可："><a href="#其实最简单的使用-tar-就只要记忆底下的方式即可：" class="headerlink" title="其实最简单的使用 tar 就只要记忆底下的方式即可："></a>其实最简单的使用 tar 就只要记忆底下的方式即可：</h2><p>  ● 压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称<br>  ● 查　询：tar -jtv -f filename.tar.bz2<br>  ● 解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录<br>  ● 压    缩：tar -zcvf <em>.tar.gz  dir/file<br>  ● 解压缩 ：tar -zxvf  </em>.tar.gz</p>
<h2 id="更多压缩详解参考地址"><a href="#更多压缩详解参考地址" class="headerlink" title="更多压缩详解参考地址"></a><a href="http://cn.linux.vbird.org/linux_basic/0240tarcompress.php" target="_blank" rel="external">更多压缩详解参考地址</a></h2><h2 id="更多举例"><a href="#更多举例" class="headerlink" title="更多举例"></a>更多举例</h2><p>01-.tar格式<br>解包：[＊＊＊＊＊＊＊]$ tar xvf FileName.tar<br>打包：[＊＊＊＊＊＊＊]$ tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）</p>
<p>02-.gz格式<br>解压1：[＊＊＊＊＊＊＊]$ gunzip FileName.gz<br>解压2：[＊＊＊＊＊＊＊]$ gzip -d FileName.gz<br>压 缩：[＊＊＊＊＊＊＊]$ gzip FileName</p>
<p>03-.tar.gz格式<br>解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tar.gz<br>压缩：[＊＊＊＊＊＊＊]$ tar zcvf FileName.tar.gz DirName</p>
<p>04-.bz2格式<br>解压1：[＊＊＊＊＊＊＊]$ bzip2 -d FileName.bz2<br>解压2：[＊＊＊＊＊＊＊]$ bunzip2 FileName.bz2<br>压 缩： [＊＊＊＊＊＊＊]$ bzip2 -z FileName</p>
<p>05-.tar.bz2格式<br>解压：[＊＊＊＊＊＊＊]$ tar jxvf FileName.tar.bz2<br>压缩：[＊＊＊＊＊＊＊]$ tar jcvf FileName.tar.bz2 DirName</p>
<p>06-.bz格式<br>解压1：[＊＊＊＊＊＊＊]$ bzip2 -d FileName.bz<br>解压2：[＊＊＊＊＊＊＊]$ bunzip2 FileName.bz</p>
<p>07-.tar.bz格式<br>解压：[＊＊＊＊＊＊＊]$ tar jxvf FileName.tar.bz</p>
<p>08-.Z格式<br>解压：[＊＊＊＊＊＊＊]$ uncompress FileName.Z<br>压缩：[＊＊＊＊＊＊＊]$ compress FileName</p>
<p>09-.tar.Z格式<br>解压：[＊＊＊＊＊＊＊]$ tar Zxvf FileName.tar.Z<br>压缩：[＊＊＊＊＊＊＊]$ tar Zcvf FileName.tar.Z DirName</p>
<p>10-.tgz格式<br>解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tgz</p>
<p>11-.tar.tgz格式<br>解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tar.tgz<br>压缩：[＊＊＊＊＊＊＊]$ tar zcvf FileName.tar.tgz FileName</p>
<p>12-.zip格式<br>解压：[＊＊＊＊＊＊＊]$ unzip FileName.zip<br>压缩：[＊＊＊＊＊＊＊]$ zip FileName.zip DirName</p>
<p>13-.lha格式<br>解压：[＊＊＊＊＊＊＊]$ lha -e FileName.lha<br>压缩：[＊＊＊＊＊＊＊]$ lha -a FileName.lha FileName</p>
<p>14-.rar格式<br>解压：[＊＊＊＊＊＊＊]$ rar a FileName.rar<br>压缩：[＊＊＊＊＊＊＊]$ rar e FileName.rar</p>
]]></content>
    
    <summary type="html">
    
      压缩是一个非常常用的功能，linux提供了非常丰富的压缩功能，本文主要介绍了最常用的压缩方法
    
    </summary>
    
      <category term="linux命令" scheme="http://heweiblog.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="压缩" scheme="http://heweiblog.top/tags/%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="tar" scheme="http://heweiblog.top/tags/tar/"/>
    
      <category term="gzip" scheme="http://heweiblog.top/tags/gzip/"/>
    
  </entry>
  
  <entry>
    <title>cetos6.8mysql安装</title>
    <link href="http://heweiblog.top/2017/09/11/cetos6-8mysql%E5%AE%89%E8%A3%85/"/>
    <id>http://heweiblog.top/2017/09/11/cetos6-8mysql安装/</id>
    <published>2017-09-11T02:20:47.000Z</published>
    <updated>2017-09-11T02:22:49.216Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>一，wget <a href="http://dev.mysql.com/get/mysql57-community-release-el6-8.noarch.rpm" target="_blank" rel="external">http://dev.mysql.com/get/mysql57-community-release-el6-8.noarch.rpm</a></p>
<p>二，yum localinstall mysql57-community-release-el6-8.noarch.rpm</p>
<p>三，yum install mysql-server</p>
<p>四，mysqld –initialize –user=mysql</p>
<p>五，找到密码 vi /var/log/mysqld.log 末尾localhost：后面就是临时密码</p>
<p>六，启动mysql服务 service mysqld start</p>
<p>七，修改密码 mysqladmin -uroot -p password 输入临时密码或复制也可以，设置新密码</p>
<p>八，chkconfig mysqld on 此步骤可做可不做</p>
<p>九，mysql -u root -p 输入密码启动</p>
]]></content>
    
    <summary type="html">
    
      mysql安装
    
    </summary>
    
      <category term="mysql" scheme="http://heweiblog.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://heweiblog.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>安装python3.5</title>
    <link href="http://heweiblog.top/2017/09/11/%E5%AE%89%E8%A3%85python3-5/"/>
    <id>http://heweiblog.top/2017/09/11/安装python3-5/</id>
    <published>2017-09-11T01:49:47.000Z</published>
    <updated>2017-09-11T01:53:27.835Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="安装python3-5可能使用的依赖"><a href="#安装python3-5可能使用的依赖" class="headerlink" title="安装python3.5可能使用的依赖"></a>安装python3.5可能使用的依赖</h2><p>[root@heweiwei heweiwei]# yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel</p>
<h2 id="到python官网找到下载路径-用wget下载"><a href="#到python官网找到下载路径-用wget下载" class="headerlink" title="到python官网找到下载路径, 用wget下载"></a>到python官网找到下载路径, 用wget下载</h2><p>[root@heweiwei heweiwei]# wget <a href="https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz" target="_blank" rel="external">https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz</a></p>
<h2 id="解压tgz包"><a href="#解压tgz包" class="headerlink" title="解压tgz包"></a>解压tgz包</h2><p>[root@heweiwei heweiwei]# tar -zxvf Python-3.5.1.tgz</p>
<h2 id="把python移到-usr-local下面"><a href="#把python移到-usr-local下面" class="headerlink" title="把python移到/usr/local下面"></a>把python移到/usr/local下面</h2><p>[root@heweiwei heweiwei]# mv Python-3.5.1 /usr/local</p>
<h2 id="删除旧版本的python依赖"><a href="#删除旧版本的python依赖" class="headerlink" title="删除旧版本的python依赖"></a>删除旧版本的python依赖</h2><p>[root@heweiwei heweiwei]# ll /usr/bin | grep python<br>-rwxr-xr-x.   1 root root      20152 May 12  2016 abrt-action-analyze-python<br>-rwxr-xr-x.   2 root root       9032 Aug 18  2016 python<br>lrwxrwxrwx.   1 root root          6 Feb 27 16:05 python2 -&gt; python<br>-rwxr-xr-x.   2 root root       9032 Aug 18  2016 python2.6<br>-rwxr-xr-x.   1 root root       1418 Aug 18  2016 python2.6-config<br>lrwxrwxrwx.   1 root root         16 Feb 28 17:21 python-config -&gt; python2.6-config</p>
<p>[root@heweiwei heweiwei]# rm -rf /usr/bin/python</p>
<p>进入python目录<br>[root@heweiwei heweiwei]# cd /usr/local/Python-3.5.1/<br>[root@heweiwei Python-3.5.1]# </p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>[root@heweiwei Python-3.5.1]# ./configure</p>
<h2 id="编译-make"><a href="#编译-make" class="headerlink" title="编译 make"></a>编译 make</h2><p>[root@heweiwei Python-3.5.1]# make</p>
<h2 id="编译，安装"><a href="#编译，安装" class="headerlink" title="编译，安装"></a>编译，安装</h2><p>[root@heweiwei Python-3.5.1]# make install</p>
<h2 id="删除旧的软链接，创建新的软链接到最新的python"><a href="#删除旧的软链接，创建新的软链接到最新的python" class="headerlink" title="删除旧的软链接，创建新的软链接到最新的python"></a>删除旧的软链接，创建新的软链接到最新的python</h2><p>[root@heweiwei Python-3.5.1]# rm -rf /usr/bin/python<br>[root@heweiwei Python-3.5.1]# ln -s /usr/local/bin/python3.5 /usr/bin/python</p>
<h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><p>[heweiwei@heweiwei ~]$ python -V<br>Python 3.5.1</p>
]]></content>
    
    <summary type="html">
    
      python3安装
    
    </summary>
    
      <category term="python" scheme="http://heweiblog.top/categories/python/"/>
    
    
      <category term="python" scheme="http://heweiblog.top/tags/python/"/>
    
      <category term="python3" scheme="http://heweiblog.top/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>rpm包制作</title>
    <link href="http://heweiblog.top/2017/09/11/rpm%E5%8C%85%E5%88%B6%E4%BD%9C/"/>
    <id>http://heweiblog.top/2017/09/11/rpm包制作/</id>
    <published>2017-09-11T01:42:59.000Z</published>
    <updated>2017-09-11T01:47:28.483Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="rpm-即软件包管理"><a href="#rpm-即软件包管理" class="headerlink" title="rpm 即软件包管理"></a>rpm 即软件包管理</h2><p>关键点：SPEC文档    </p>
<h2 id="生成工作目录："><a href="#生成工作目录：" class="headerlink" title="生成工作目录："></a>生成工作目录：</h2><p>[root@localhost heweiwei]# yum install rpmdevtools<br>[heweiwei@localhost ~]$ rpmdev-setuptree        此命令用来生成 rpmbuild 目录<br>[heweiwei@localhost ~]$ ls rpmbuild/<br>BUILD  RPMS  SOURCES  SPECS  SRPMS</p>
<h2 id="目录分配："><a href="#目录分配：" class="headerlink" title="目录分配："></a>目录分配：</h2><p>SOURCES放置打包资源，包括源码打包文件和补丁文件等；<br>SPECS目录放置SPEC文档；<br>BUILD打包过程中的工作目录；<br>RPMS目录存放生成的二进制包，RPM包根据硬件平台不同分类，i386表示生成i386结构的包将存放在该目录下;<br>SRPMS目录存放生成的源码包。</p>
<h2 id="撰写SPEC文档-（最为核心）"><a href="#撰写SPEC文档-（最为核心）" class="headerlink" title="撰写SPEC文档 （最为核心）"></a>撰写SPEC文档 （最为核心）</h2><p>SPEC文档包括了 rpm打包过程的操作内容和新生成rpm包的基本信息等 它的作用对象是打包程序 rpmbuild<br>SPEC文档编写参考模板文件然后一步步扩展</p>
<p>生成rpm包的源代码、shell脚本、配置文件都拷贝到SOURCES目录里，注意通常情况下源码的压缩格式都为*.tar.gz格式<br>然后，将最最最重要的SPEC文件，命名格式一般是“软件名-版本.spec”的形式，将其拷贝到SPECS目录，切换到该目录下执行<br>rpmbuild -ba 软件名-版本.spec<br>-ba表示build all，即生成包括二进制包和源代码包的所有RPM包，<br>如果正常的话，rpmbuild将正常退出，同时在RPMS目录和SRPMS目录中将生成对应的RPM包。</p>
<p>关键就是SPEC文件的写法，我们可以用rpmdev-newspec -o Name-version.spec命令来生成SPEC文件的模板，<br>然后在上面修改即可</p>
<h2 id="创建-安装-卸载"><a href="#创建-安装-卸载" class="headerlink" title="创建 安装 卸载"></a>创建 安装 卸载</h2><p>rpmbuild -bb edns_dial.spec    创建rpm包<br>rpm -qlp /root/rpmbuild/RPMS/x86_64/edns_dial-1.1.1.5-1.el6.x86_64.rpm    查看安装情况<br>rpm -ivh edns_dial-1.1.1.5-1.el6.x86_64.rpm      安装<br>rpm -ivh edns_dial-1.1.1.5-1.el6.x86_64.rpm  –force（发生冲突强制执行）<br>rpm -e ends_dial        卸载</p>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>出现此情况<br>libcrypto.so.10()(64bit) is needed by edns_dial-1.1.1.5-1.el6.x86_64<br>file /usr/bin/edns_dial from install of edns_dial-1.1.1.5-1.el6.x86_64 conflicts<br>with file from package dnsys-3.1.1.368-ydns_743863.x86_64<br>用此命令<br>rpm -ivh edns_dial-1.1.1.5-1.el6.x86_64.rpm –nodeps –force        </p>
<p>rpm包安装后的可执行程序一般为release版本若想要保留调试信息则应该在spec文件加入以下信息<br>调试信息的作用不大，一般自动删除调试信息</p>
<p>%define debug_package %{nil}<br>%define __strip /bin/true</p>
<p>[root@localhost BUILD]# rpm -ivh /root/rpmbuild/RPMS/x86_64/edns_dial-1.1.1.7-1.el6.x86_64.rpm<br>Preparing…                ########################################### [100%]<br>1:edns_dial              ########################################### [100%]<br>[root@localhost BUILD]# md5sum edns_dial-1.1.1.7/edns_dial<br>f569fa864f820a4a0dc3d30f057ca4e5  edns_dial-1.1.1.7/edns_dial<br>[root@localhost BUILD]# md5sum /usr/bin/edns_dial<br>f569fa864f820a4a0dc3d30f057ca4e5  /usr/bin/edns_dial<br>[root@localhost BUILD]# rpm -e edns_dial<br>[root@localhost BUILD]#<br>对比后md5值一模一样</p>
<h2 id="卸载出现此情况解决方案"><a href="#卸载出现此情况解决方案" class="headerlink" title="卸载出现此情况解决方案"></a>卸载出现此情况解决方案</h2><p>[root@localhost heweiwei]# rpm -e edns_dial<br>error: “edns_dial” specifies multiple packages:<br>edns_dial-1.1.1.5-enterprise.el6.x86_64<br>edns_dial-1.1.1.5-1.el6.x86_64<br>[root@localhost heweiwei]# rpm -e edns_dial –allmatches<br>edns_dial-1.1.1.5-enterprise.el6.x86_64 edns_dial-1.1.1.5-1.el6.x86_64</p>
<p>rpmbuild –showrc | grep topdir      查看系统默认的工作车间<br>自定义目录（车间）<br>vi ~/.rpmmacros<br>%_topdir        /home/heweiwei/rpmbuild    ##目录可以自定义<br>mkdir ~/rpmbuild<br>cd ~/rpmbuild<br>mkdir -pv {BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS} </p>
<p>rpm -qi edns_dial 查看 rpm 包安装程序的详细信息</p>
]]></content>
    
    <summary type="html">
    
      rpm包相当于windows下的软件安装包
    
    </summary>
    
      <category term="linux基础" scheme="http://heweiblog.top/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="rpm" scheme="http://heweiblog.top/tags/rpm/"/>
    
      <category term="打包" scheme="http://heweiblog.top/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>快速入门shell脚本</title>
    <link href="http://heweiblog.top/2017/09/08/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8shell%E8%84%9A%E6%9C%AC/"/>
    <id>http://heweiblog.top/2017/09/08/快速入门shell脚本/</id>
    <published>2017-09-08T10:31:50.000Z</published>
    <updated>2017-09-08T10:37:52.831Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="参考原文地址"><a href="#参考原文地址" class="headerlink" title="参考原文地址"></a>参考原文地址</h2><p>[快速入门shell脚本]<br><a href="http://c.biancheng.net/cpp/view/2736.html" target="_blank" rel="external">http://c.biancheng.net/cpp/view/2736.html</a></p>
<h2 id="变量-含义"><a href="#变量-含义" class="headerlink" title="变量    含义"></a>变量    含义</h2><p>$0    当前脚本的文件名<br>$n    传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。<br>$#    传递给脚本或函数的参数个数。<br>$<em>    传递给脚本或函数的所有参数。<br>$@    传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $</em> 稍有不同，下面将会讲到。<br>$?    上个命令的退出状态，或函数的返回值。<br>$$    当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</p>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="$* 和 $@ 的区别"></a>$* 和 $@ 的区别</h2><p>$<em> 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。<br>但是当它们被双引号(“ “)包含时，”$</em>“ 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；<br>“$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<h2 id="算术运算符列表"><a href="#算术运算符列表" class="headerlink" title="算术运算符列表"></a>算术运算符列表</h2><p>a = 10<br>b = 20<br>运算符    说明    举例</p>
<ul>
<li>加法    <code>expr $a + $b</code> 结果为 30。</li>
</ul>
<ul>
<li>减法    <code>expr $a - $b</code> 结果为 -10。</li>
</ul>
<ul>
<li>乘法    <code>expr $a \* $b</code> 结果为  200。<br>/    除法    <code>expr $b / $a</code> 结果为 2。<br>%    取余    <code>expr $b % $a</code> 结果为 0。<br>=    赋值    a=$b 将把变量 b 的值赋给 a。<br>==    相等。用于比较两个数字，相同则返回 true。    [ $a == $b ] 返回 false。<br>!=    不相等。用于比较两个数字，不相同则返回 true。    [ $a != $b ] 返回 true。<br>注意：条件表达式要放在方括号之间，并且要有空格，例如 [$a==$b] 是错误的，必须写成 [ $a == $b ]。</li>
</ul>
<h2 id="关系运算符列表"><a href="#关系运算符列表" class="headerlink" title="关系运算符列表"></a>关系运算符列表</h2><p>运算符    说明    举例<br>-eq    检测两个数是否相等，相等返回 true。    [ $a -eq $b ] 返回 true。<br>-ne    检测两个数是否相等，不相等返回 true。    [ $a -ne $b ] 返回 true。<br>-gt    检测左边的数是否大于右边的，如果是，则返回 true。    [ $a -gt $b ] 返回 false。<br>-lt    检测左边的数是否小于右边的，如果是，则返回 true。    [ $a -lt $b ] 返回 true。<br>-ge    检测左边的数是否大等于右边的，如果是，则返回 true。    [ $a -ge $b ] 返回 false。<br>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。    [ $a -le $b ] 返回 true。</p>
<h2 id="布尔运算符列表"><a href="#布尔运算符列表" class="headerlink" title="布尔运算符列表"></a>布尔运算符列表</h2><p>运算符    说明    举例<br>!    非运算，表达式为 true 则返回 false，否则返回 true。    [ ! false ] 返回 true。<br>-o    或运算，有一个表达式为 true 则返回 true。    [ $a -lt 20 -o $b -gt 100 ] 返回 true。<br>-a    与运算，两个表达式都为 true 才返回 true。    [ $a -lt 20 -a $b -gt 100 ] 返回 false。</p>
<h2 id="字符串运算符列表"><a href="#字符串运算符列表" class="headerlink" title="字符串运算符列表"></a>字符串运算符列表</h2><p>运算符    说明    举例<br>=    检测两个字符串是否相等，相等返回 true。    [ $a = $b ] 返回 false。<br>!=    检测两个字符串是否相等，不相等返回 true。    [ $a != $b ] 返回 true。<br>-z    检测字符串长度是否为0，为0返回 true。    [ -z $a ] 返回 false。<br>-n    检测字符串长度是否为0，不为0返回 true。    [ -z $a ] 返回 true。<br>str    检测字符串是否为空，不为空返回 true。    [ $a ] 返回 true。</p>
<h2 id="文件测试运算符列表"><a href="#文件测试运算符列表" class="headerlink" title="文件测试运算符列表"></a>文件测试运算符列表</h2><p>操作符    说明    举例<br>-b file    检测文件是否是块设备文件，如果是，则返回 true。    [ -b $file ] 返回 false。<br>-c file    检测文件是否是字符设备文件，如果是，则返回 true。    [ -b $file ] 返回 false。<br>-d file    检测文件是否是目录，如果是，则返回 true。    [ -d $file ] 返回 false。<br>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    [ -f $file ] 返回 true。<br>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。    [ -g $file ] 返回 false。<br>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。    [ -k $file ] 返回 false。<br>-p file    检测文件是否是具名管道，如果是，则返回 true。    [ -p $file ] 返回 false。<br>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。    [ -u $file ] 返回 false。<br>-r file    检测文件是否可读，如果是，则返回 true。    [ -r $file ] 返回 true。<br>-w file    检测文件是否可写，如果是，则返回 true。    [ -w $file ] 返回 true。<br>-x file    检测文件是否可执行，如果是，则返回 true。    [ -x $file ] 返回 true。<br>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。    [ -s $file ] 返回 true。<br>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。    [ -e $file ] 返回 true。</p>
<h2 id="全部可用的重定向命令列表"><a href="#全部可用的重定向命令列表" class="headerlink" title="全部可用的重定向命令列表"></a>全部可用的重定向命令列表</h2><p>命令    说明<br>command &gt; file    将输出重定向到 file。<br>command &lt; file    将输入重定向到 file。<br>command &gt;&gt; file    将输出以追加的方式重定向到 file。<br>n &gt; file    将文件描述符为 n 的文件重定向到 file。<br>n &gt;&gt; file    将文件描述符为 n 的文件以追加的方式重定向到 file。<br>n &gt;&amp; m    将输出文件 m 和 n 合并。<br>n &lt;&amp; m    将输入文件 m 和 n 合并。<br>&lt;&lt; tag    将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>
]]></content>
    
    <summary type="html">
    
      shell脚本轻巧使用，很有学习的价值，快速入门shell脚本一些语法及其使用
    
    </summary>
    
      <category term="linux基础" scheme="http://heweiblog.top/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="shell" scheme="http://heweiblog.top/tags/shell/"/>
    
      <category term="inux" scheme="http://heweiblog.top/tags/inux/"/>
    
  </entry>
  
  <entry>
    <title>bind-9.11.2源码安装配置</title>
    <link href="http://heweiblog.top/2017/09/07/bind-9-11-2%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://heweiblog.top/2017/09/07/bind-9-11-2源码安装配置/</id>
    <published>2017-09-07T08:16:57.000Z</published>
    <updated>2017-09-08T05:03:24.746Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>资源<br>apt yum 均可 安装bind 但这里不做介绍，本文主要介源码安装<br><a href="https://ftp.isc.org/isc/bind9/" target="_blank" rel="external">源码下载地址</a>选择比较稳定的版本进行下载<br>本文用的是最新版本bind-9.11.2</p>
<p>解压<br>tar -zxvf bind-9.11.2.tar.gz</p>
<p>配置<br>./configure –prefix=/usr/local/bind9 –enable-threads –enable-static –enable-ipv6=yes</p>
<p>安装<br>make &amp;&amp; make install</p>
<p>安装结束之后 建立目录结构<br>cd /usr/local/bind9/<br>mkdir var/named<br>mkdir /usr/local/bind9/var/logs<br>touch var/run/named.pid<br>touch var/named_dump.db<br>touch var/run/named.stats</p>
<p>获取最新的根配置<br>cd var/named<br>wget ftp://ftp.rs.internic.net/domain/named.root<br>mv named.root named.ca</p>
<h2 id="配置主配置文件"><a href="#配置主配置文件" class="headerlink" title="配置主配置文件"></a>配置主配置文件</h2><p>cd /usr/local/bind9/etc/</p>
<p>具体配置参考<a href="https://wenku.baidu.com/view/1dad0af604a1b0717fd5dd4f.html" target="_blank" rel="external">百度文库</a></p>
<h3 id="named-conf"><a href="#named-conf" class="headerlink" title="named.conf"></a>named.conf</h3><p> options { </p>
<pre><code>directory &quot;/usr/local/bind9/var/named&quot;; 

pid-file  &quot;/usr/local/bind9/var/run/named.pid&quot;; 

dump-file &quot;/usr/local/bind9/var/named_dump.db&quot;; 

statistics-file &quot;/usr/local/bind9/var/run/named.stats&quot;; 
</code></pre><p>};</p>
<p>// Log </p>
<p>logging { </p>
<pre><code>channel error_log {

        file &quot;/usr/local/bind9/var/logs/error.log&quot; versions 10 size 32m;

        severity warning;

        print-time yes;

        print-severity yes;

        print-category yes;

}; 

channel query_log {

        file &quot;/usr/local/bind9/var/logs/query.log&quot; versions 10 size 32m;

        severity info;

        print-time yes;

        print-severity yes;

        print-category yes;

}; 

category default { error_log; }; 

category queries { query_log; }; 
</code></pre><p>};</p>
<p>// RNDC </p>
<p>key “rndc-key” {<br>      algorithm hmac-md5;<br>      secret “D1rQg6l6lLExdxGMlJOEuA==”;<br>};</p>
<p>controls {<br>      inet 127.0.0.1 port 953<br>              allow { 127.0.0.1; } keys { “rndc-key”; };<br>};</p>
<p>// Cacheing Only Name Server Config </p>
<p>zone “.” IN { </p>
<pre><code>type hint; 

file &quot;named.ca&quot;; 
</code></pre><p>};</p>
<p>// localhost. </p>
<p>zone “localhost” IN { </p>
<pre><code>type master; 

file &quot;localhost.zone&quot;; 

allow-update { none; }; 
</code></pre><p>};</p>
<p>zone “0.0.127.in-addr.arpa” IN { </p>
<pre><code>type master; 

file &quot;localhost.rzone&quot;; 

allow-update { none; }; 
</code></pre><p>};</p>
<p>// abc.com. </p>
<p>zone “abc.com” IN { </p>
<pre><code>type master; 

file &quot;abc.com.zone&quot;; 

allow-update { none; }; 
</code></pre><p>};</p>
<p>zone “0.0.10.in-addr.arpa” IN {<br>        type master; </p>
<pre><code>file &quot;abc.com.rzone&quot;; 

allow-update { none; }; 
</code></pre><p>};</p>
<h3 id="named-ca"><a href="#named-ca" class="headerlink" title="named.ca"></a>named.ca</h3><p>;       This file holds the information on root name servers needed to<br>;       initialize cache of Internet domain name servers<br>;       (e.g. reference this file in the “cache  .  <file>“<br>;       configuration file of BIND domain name servers).<br>;<br>;       This file is made available by InterNIC<br>;       under anonymous FTP as<br>;           file                /domain/named.cache<br>;           on server           FTP.INTERNIC.NET<br>;       -OR-                    RS.INTERNIC.NET<br>;<br>;       last update:     August 29, 2017<br>;       related version of root zone:     2017082901<br>;<br>; FORMERLY NS.INTERNIC.NET<br>;<br>.                        3600000      NS    A.ROOT-SERVERS.NET.<br>A.ROOT-SERVERS.NET.      3600000      A     198.41.0.4<br>A.ROOT-SERVERS.NET.      3600000      AAAA  2001:503:ba3e::2:30<br>;<br>; FORMERLY NS1.ISI.EDU<br>;<br>.                        3600000      NS    B.ROOT-SERVERS.NET.<br>B.ROOT-SERVERS.NET.      3600000      A     192.228.79.201<br>B.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:200::b<br>;<br>; FORMERLY C.PSI.NET<br>;<br>.                        3600000      NS    C.ROOT-SERVERS.NET.<br>C.ROOT-SERVERS.NET.      3600000      A     192.33.4.12<br>C.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:2::c<br>;<br>; FORMERLY TERP.UMD.EDU<br>;<br>.                        3600000      NS    D.ROOT-SERVERS.NET.<br>D.ROOT-SERVERS.NET.      3600000      A     199.7.91.13<br>D.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:2d::d<br>;<br>; FORMERLY NS.NASA.GOV<br>;<br>.                        3600000      NS    E.ROOT-SERVERS.NET.<br>E.ROOT-SERVERS.NET.      3600000      A     192.203.230.10<br>E.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:a8::e<br>;<br>; FORMERLY NS.ISC.ORG<br>;<br>.                        3600000      NS    F.ROOT-SERVERS.NET.<br>F.ROOT-SERVERS.NET.      3600000      A     192.5.5.241<br>F.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:2f::f<br>;<br>; FORMERLY NS.NIC.DDN.MIL<br>;<br>.                        3600000      NS    G.ROOT-SERVERS.NET.<br>G.ROOT-SERVERS.NET.      3600000      A     192.112.36.4<br>G.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:12::d0d<br>;<br>; FORMERLY AOS.ARL.ARMY.MIL<br>;<br>.                        3600000      NS    H.ROOT-SERVERS.NET.<br>H.ROOT-SERVERS.NET.      3600000      A     198.97.190.53<br>H.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:1::53<br>;<br>; FORMERLY NIC.NORDU.NET<br>;<br>.                        3600000      NS    I.ROOT-SERVERS.NET.<br>I.ROOT-SERVERS.NET.      3600000      A     192.36.148.17<br>I.ROOT-SERVERS.NET.      3600000      AAAA  2001:7fe::53<br>;<br>; OPERATED BY VERISIGN, INC.<br>;<br>.                        3600000      NS    J.ROOT-SERVERS.NET.<br>J.ROOT-SERVERS.NET.      3600000      A     192.58.128.30<br>J.ROOT-SERVERS.NET.      3600000      AAAA  2001:503:c27::2:30<br>;<br>; OPERATED BY RIPE NCC<br>;<br>.                        3600000      NS    K.ROOT-SERVERS.NET.<br>K.ROOT-SERVERS.NET.      3600000      A     193.0.14.129<br>K.ROOT-SERVERS.NET.      3600000      AAAA  2001:7fd::1<br>;<br>; OPERATED BY ICANN<br>;<br>.                        3600000      NS    L.ROOT-SERVERS.NET.<br>L.ROOT-SERVERS.NET.      3600000      A     199.7.83.42<br>L.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:9f::42<br>;<br>; OPERATED BY WIDE<br>;<br>.                        3600000      NS    M.ROOT-SERVERS.NET.<br>M.ROOT-SERVERS.NET.      3600000      A     202.12.27.33<br>M.ROOT-SERVERS.NET.      3600000      AAAA  2001:dc3::35<br>; End of file</file></p>
<h3 id="localhost-zone"><a href="#localhost-zone" class="headerlink" title="localhost.zone"></a>localhost.zone</h3><p>$TTL 86400 </p>
<p>$ORIGIN localhost. </p>
<p>@   IN  SOA localhost. root.localhost. ( </p>
<pre><code>2006083100       Serial (YYMMDDSN) 

1800             Refresh 

300              Retry 

3600             Expiry 

300 )            Minimum 
</code></pre><p>@   IN  NS  localhost. </p>
<p>@   IN  A   127.0.0.1 </p>
<h3 id="localhost-rzone"><a href="#localhost-rzone" class="headerlink" title="localhost.rzone"></a>localhost.rzone</h3><p> $TTL 86400 </p>
<p>@   IN  SOA localhost. root.localhost.  ( </p>
<pre><code>2006083100   Serial (YYMMDDSN) 

30M          Refresh 

5M           Retry 

1H           Expire 

5M )         Minimum 
</code></pre><p>@   IN  NS  localhost. </p>
<p>1   IN  PTR localhost</p>
<h3 id="abc-com-zone"><a href="#abc-com-zone" class="headerlink" title="abc.com.zone"></a>abc.com.zone</h3><p>$TTL 600</p>
<p>$ORIGIN abc.net.</p>
<p>@   IN  SOA abc.net. webmaster.abc.com. (</p>
<pre><code>2006083100       Serial (YYMMDDSN)



1800             Refresh



300              Retry



3600             Expiry



300 )            Minimum
</code></pre><p>@   IN  NS  ns1.abc.com.</p>
<p>@   IN  A   10.0.0.97</p>
<p>ns1 IN  A   10.0.0.97</p>
<p>www IN  A   10.0.0.97</p>
<p>web IN  CNAME   www</p>
<p>mail IN MX 10.0.0.97</p>
<h3 id="abc-com-rzone"><a href="#abc-com-rzone" class="headerlink" title="abc.com.rzone"></a>abc.com.rzone</h3><p>$TTL 86400 </p>
<p>@   IN  SOA localhost. root.localhost.  ( </p>
<pre><code>2006083100   Serial (YYMMDDSN) 

30M          Refresh 

5M           Retry 

1H           Expire 

5M )         Minimum 
</code></pre><p>@   IN  NS  localhost. </p>
<p>1   IN  PTR localhost</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>/usr/local/bind9/sbin/named -gc /usr/local/bind9/etc/named.conf<br>带日志启动<br>不带日志去掉 -g 参数</p>
<h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><p>vim /etc/rc.d/init.d/named<br>if [ <code>id -u</code> -ne 0 ]<br>then<br>echo “ERROR:For bind to port 53,must run as root.”<br>exit 1<br>fi<br>case “$1” in</p>
<p>start)<br>if [ -x /usr/local/bind9/sbin/named ]; then<br>/usr/local/bind9/sbin/named -c /usr/local/bind9/etc/named.conf &amp;&amp; echo ‘start named [ok]’<br>fi<br>;;</p>
<p>stop)<br>kill <code>cat /usr/local/bind9/var/run/named.pid</code> &amp;&amp; echo ‘stop named [ok]’<br>;;<br>restart)<br>echo “restart named”<br>$0 stop<br>$0 start<br>;;<br>*)<br>echo “$0 start | stop | restart”<br>;;</p>
<p>esac</p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>service named start<br>设置为开机启动<br>编辑文件 vim /etc/rc.d/rc.local 添加以下内容即可<br>/etc/rc.d/init.d/named start<br><a href="http://www.linuxidc.com/Linux/2012-09/71497.htm" target="_blank" rel="external">参考文章</a></p>
<h3 id="更改首选服务器为自己"><a href="#更改首选服务器为自己" class="headerlink" title="更改首选服务器为自己"></a>更改首选服务器为自己</h3><p>vim /etc/resolv.conf<br>nameserver 127.0.0.1</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此一个滑溜溜的DNS 服务器就配置好了 这只是冰山一角</p>
]]></content>
    
    <summary type="html">
    
      如何使用开源dns服务软件bind使用
    
    </summary>
    
      <category term="bind" scheme="http://heweiblog.top/categories/bind/"/>
    
    
      <category term="DNS" scheme="http://heweiblog.top/tags/DNS/"/>
    
      <category term="bind" scheme="http://heweiblog.top/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>服务器性能测试</title>
    <link href="http://heweiblog.top/2017/09/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>http://heweiblog.top/2017/09/06/服务器性能测试/</id>
    <published>2017-09-06T02:43:04.000Z</published>
    <updated>2017-09-06T12:16:41.653Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h2><p>首先对吞吐量（）、QPS、并发数、响应时间（RT）几个概念一直比较模糊，也不知道哪些指标可以较好的衡量系统的性能。今天特意查了些资料做一些记录：首先看一些概念（来自百度百科）</p>
<h3 id="1-响应时间-RT"><a href="#1-响应时间-RT" class="headerlink" title="1. 响应时间(RT)"></a>1. 响应时间(RT)</h3><p>　　响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。<br>　　对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。</p>
<h3 id="2-吞吐量-Throughput"><a href="#2-吞吐量-Throughput" class="headerlink" title="2. 吞吐量(Throughput)"></a>2. 吞吐量(Throughput)</h3><p>吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间或者系统响应时间和应用延迟时间,可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。<br>　　对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。</p>
<h3 id="3-并发用户数"><a href="#3-并发用户数" class="headerlink" title="3. 并发用户数"></a>3. 并发用户数</h3><p>　　并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。</p>
<ol>
<li>QPS每秒查询率(Query Per Second)<br>　　每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</li>
</ol>
<p>从以上概念来看吞吐量和响应时间是衡量系统性能的重要指标，QPS虽然和吞吐量的计量单位不同，但应该是成正比的，任何一个指标都可以含量服务器的并行处理能力。当然Throughput更关心数据量，QPS更关心处理笔数。</p>
<p>QPS提升带来什么？QPS提升说明单台服务器处理能力提升，如果QPS提升1倍，服务器资源减少1半，或者说服务器不变可以支撑2倍的请求量。<br>如何提升QPS？<br>1）减少CPU的使用时间（哪些代码会消耗CPU：循环、字符串拼接\查找\替换、编码\解码、序列化\反序列化、压缩）<br>2）增加CPU的数量<br>3）减少同步锁<br>（如果CPU不能被压到85%以上，并且此时的QPS已经达到了峰值，则说明另有瓶颈，接下去关注内存）<br>RT提升带来什么？<br>响应速度提升说明单词请求的处理速度提升，用户感觉任务处理速度更快，系统反应速度更快。当然在处理能力不变的情况下，RT的提升必然会提升QPS。<br>如何提升RT？<br>1）减少I/O的响应时间<br>2）减少I/O的调用次数<br>3）减少CPU使用时间（当然在I/O占大头的应用里，这方面优化效果肯定不明显）<br>PV=page view    访问量 浏览量<br>TPS=transactions per second    每秒事务数<br>QPS=queries per second 每秒查询数 每秒可以处理多少查询<br>RPS=requests per second  每秒处理的请求数<br>RPS=并发数/平均响应时间</p>
<h2 id="一．系统吞度量要素："><a href="#一．系统吞度量要素：" class="headerlink" title="一．系统吞度量要素："></a>一．系统吞度量要素：</h2><p>  一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。<br>单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。<br>系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间<br>     QPS（TPS）：每秒钟request/事务 数量<br>        并发数： 系统同时处理的request/事务数<br>        响应时间：  一般取平均响应时间<br>（很多人经常会把并发数和TPS理解混淆）<br>理解了上面三个要素的意义之后，就能推算出它们之间的关系：<br>QPS（TPS）= 并发数/平均响应时间<br>        一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。<br>决定系统响应时间要素<br>我们做项目要排计划，可以多人同时并发做多项任务，也可以一个人或者多个人串行工作，始终会有一条关键路径，这条路径就是项目的工期。<br>系统一次调用的响应时间跟项目计划一样，也有一条关键路径，这个关键路径是就是系统影响时间；<br>关键路径是有CPU运算、IO、外部系统响应等等组成。</p>
<h2 id="二．系统吞吐量评估："><a href="#二．系统吞吐量评估：" class="headerlink" title="二．系统吞吐量评估："></a>二．系统吞吐量评估：</h2><p>我们在做系统设计的时候就需要考虑CPU运算、IO、外部系统响应因素造成的影响以及对系统性能的初步预估。<br>而通常境况下，我们面对需求，我们评估出来的出来QPS、并发数之外，还有另外一个维度：日PV。<br>通过观察系统的访问日志发现，在用户量很大的情况下，各个时间周期内的同一时间段的访问流量几乎一样。比如工作日的每天早上。只要能拿到日流量图和QPS我们就可以推算日流量。<br>通常的技术方法：</p>
<ol>
<li>找出系统的最高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外）</li>
<li>通过压力测试或者经验预估，得出最高TPS，然后跟进1的关系，计算出系统最高的日吞吐量。B2B中文和淘宝面对的客户群不一样，这两个客户群的网络行为不应用，他们之间的TPS和PV关系比例也不一样。</li>
</ol>
<p>A)淘宝<br>淘宝流量图：</p>
<p>淘宝的TPS和PV之间的关系通常为  最高TPS：PV大约为 1 : 11<em>3600 （相当于按最高TPS访问11个小时，这个是商品详情的场景，不同的应用场景会有一些不同）<br>B) B2B中文站<br>B2B的TPS和PV之间的关系不同的系统不同的应用场景比例变化比较大，粗略估计在1 : 8个小时左右的关系（09年对offerdetail的流量分析数据）。旺铺和offerdetail这两个比例相差很大，可能是因为爬虫暂的比例较高的原因导致。<br>在淘宝环境下，假设我们压力测试出的TPS为100，那么这个系统的日吞吐量=100</em>11*3600=396万<br>这个是在简单（单一url）的情况下，有些页面，一个页面有多个request，系统的实际吞吐量还要小。<br>无论有无思考时间（T_think），测试所得的TPS值和并发虚拟用户数(U_concurrent)、Loadrunner读取的交易响应时间（T_response）之间有以下关系（稳定运行情况下）：<br>TPS=U_concurrent / (T_response+T_think)。<br>并发数、QPS、平均响应时间三者之间关系</p>
<p>来源：<a href="http://www.cnblogs.com/jackei/" target="_blank" rel="external">http://www.cnblogs.com/jackei/</a></p>
<h2 id="软件性能测试的基本概念和计算公式"><a href="#软件性能测试的基本概念和计算公式" class="headerlink" title="软件性能测试的基本概念和计算公式"></a>软件性能测试的基本概念和计算公式</h2><h3 id="一、软件性能的关注点"><a href="#一、软件性能的关注点" class="headerlink" title="一、软件性能的关注点"></a>一、软件性能的关注点</h3><p>对一个软件做性能测试时需要关注那些性能呢？<br>我们想想在软件设计、部署、使用、维护中一共有哪些角色的参与，然后再考虑这些角色各自关注的性能点是什么，作为一个软件性能测试工程师，我们又该关注什么？<br>首先，开发软件的目的是为了让用户使用，我们先站在用户的角度分析一下，用户需要关注哪些性能。<br>对于用户来说，当点击一个按钮、链接或发出一条指令开始，到系统把结果已用户感知的形式展现出来为止，这个过程所消耗的时间是用户对这个软件性能的直观印象。也就是我们所说的响应时间，当相应时间较小时，用户体验是很好的，当然用户体验的响应时间包括个人主观因素和客观响应时间，在设计软件时，我们就需要考虑到如何更好地结合这两部分达到用户最佳的体验。如：用户在大数据量查询时，我们可以将先提取出来的数据展示给用户，在用户看的过程中继续进行数据检索，这时用户并不知道我们后台在做什么。<br>用户关注的是用户操作的相应时间。<br>其次，我们站在管理员的角度考虑需要关注的性能点。<br>1、 相应时间<br>2、 服务器资源使用情况是否合理<br>3、 应用服务器和数据库资源使用是否合理<br>4、 系统能否实现扩展<br>5、 系统最多支持多少用户访问、系统最大业务处理量是多少<br>6、 系统性能可能存在的瓶颈在哪里<br>7、 更换那些设备可以提高性能<br>8、 系统能否支持7×24小时的业务访问<br>再次，站在开发（设计）人员角度去考虑。<br>1、 架构设计是否合理<br>2、 数据库设计是否合理<br>3、 代码是否存在性能方面的问题<br>4、 系统中是否有不合理的内存使用方式<br>5、 系统中是否存在不合理的线程同步方式<br>6、 系统中是否存在不合理的资源竞争<br>那么站在性能测试工程师的角度，我们要关注什么呢？<br>一句话，我们要关注以上所有的性能点。</p>
<h3 id="二、软件性能的几个主要术语"><a href="#二、软件性能的几个主要术语" class="headerlink" title="二、软件性能的几个主要术语"></a>二、软件性能的几个主要术语</h3><p>1、响应时间：对请求作出响应所需要的时间<br>网络传输时间：N1+N2+N3+N4<br>应用服务器处理时间：A1+A3<br>数据库服务器处理时间：A2<br>响应时间=N1+N2+N3+N4+A1+A3+A2<br>2、并发用户数的计算公式<br>系统用户数：系统额定的用户数量，如一个OA系统，可能使用该系统的用户总数是5000个，那么这个数量，就是系统用户数。<br>同时在线用户数：在一定的时间范围内，最大的同时在线用户数量。<br>同时在线用户数=每秒请求数RPS（吞吐量）+并发连接数+平均用户思考时间<br>平均并发用户数的计算：C=nL / T<br>其中C是平均的并发用户数，n是平均每天访问用户数（login session），L是一天内用户从登录到退出的平均时间（login session的平均时间），T是考察时间长度（一天内多长时间有用户使用系统）<br>并发用户数峰值计算：C^约等于C + 3<em>根号C<br>其中C^是并发用户峰值，C是平均并发用户数，该公式遵循泊松分布理论。<br>3、吞吐量的计算公式<br>指单位时间内系统处理用户的请求数<br>从业务角度看，吞吐量可以用：请求数/秒、页面数/秒、人数/天或处理业务数/小时等单位来衡量<br>从网络角度看，吞吐量可以用：字节/秒来衡量<br>对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，他能够说明系统的负载能力<br>以不同方式表达的吞吐量可以说明不同层次的问题，例如，以字节数/秒方式可以表示数要受网络基础设施、服务器架构、应用服务器制约等方面的瓶颈；已请求数/秒的方式表示主要是受应用服务器和应用代码的制约体现出的瓶颈。<br>当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU </em> R /<br>其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间<br>4、性能计数器<br>是描述服务器或操作系统性能的一些数据指标，如使用内存数、进程时间，在性能测试中发挥着“监控和分析”的作用，尤其是在分析统统可扩展性、进行新能瓶颈定位时有着非常关键的作用。<br>资源利用率：指系统各种资源的使用情况，如cpu占用率为68%，内存占用率为55%，一般使用“资源实际使用/总的资源可用量”形成资源利用率。<br>5、思考时间的计算公式<br>Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做新能测试时，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。<br>在吞吐量这个公式中F=VU <em> R / T说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R = T / TS<br>下面给出一个计算思考时间的一般步骤：<br>A、首先计算出系统的并发用户数<br>C=nL / T F=R×C<br>B、统计出系统平均的吞吐量<br>F=VU </em> R / T R×C = VU <em> R / T<br>C、统计出平均每个用户发出的请求数量<br>R=u</em>C*T/VU<br>D、根据公式计算出思考时间<br>TS=T/R</p>
]]></content>
    
    <summary type="html">
    
      本文涉及系统吞吐量 QPS 用户并发量 性能测试等内容
    
    </summary>
    
      <category term="服务器" scheme="http://heweiblog.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="DNS" scheme="http://heweiblog.top/tags/DNS/"/>
    
      <category term="QPS" scheme="http://heweiblog.top/tags/QPS/"/>
    
      <category term="性能" scheme="http://heweiblog.top/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>有趣的linux命令</title>
    <link href="http://heweiblog.top/2017/09/05/%E6%9C%89%E8%B6%A3%E7%9A%84linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://heweiblog.top/2017/09/05/有趣的linux命令/</id>
    <published>2017-09-05T12:20:09.000Z</published>
    <updated>2017-09-05T12:22:04.234Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="fuck命令"><a href="#fuck命令" class="headerlink" title="fuck命令"></a>fuck命令</h2><p>首先安装pip3 或者 pip<br>pip3 install thefuck<br>eval $(thefuck –alias)<br>source ~/.bashrc</p>
<h2 id="sl-命令"><a href="#sl-命令" class="headerlink" title="sl 命令"></a>sl 命令</h2><p>sudo apt install sl<br>sl 会看到一辆火车从屏幕闪过</p>
<h2 id="fortune命令"><a href="#fortune命令" class="headerlink" title="fortune命令"></a>fortune命令</h2><p>sudo apt install fortune<br>fortune</p>
<h2 id="cmatrix命令-矩阵效果"><a href="#cmatrix命令-矩阵效果" class="headerlink" title="cmatrix命令 矩阵效果"></a>cmatrix命令 矩阵效果</h2><p>sudo apt-get install cmatrix<br>cmatrix</p>
<h2 id="cal命令打印日历"><a href="#cal命令打印日历" class="headerlink" title="cal命令打印日历"></a>cal命令打印日历</h2><p>   September 2017<br>Su Mo Tu We Th Fr Sa<br>                1  2<br> 3  4  5  6  7  8  9<br>10 11 12 13 14 15 16<br>17 18 19 20 21 22 23<br>24 25 26 27 28 29 30  </p>
<h2 id="figlet-、toilet命令-艺术字"><a href="#figlet-、toilet命令-艺术字" class="headerlink" title="figlet 、toilet命令 艺术字"></a>figlet 、toilet命令 艺术字</h2><p>安装同上<br>sudo apt-get install figlet<br>sudo apt-get install toilet<br>figlet i love you<br>toilet i love you</p>
<h2 id="shred-命令-搞破坏-哈哈哈"><a href="#shred-命令-搞破坏-哈哈哈" class="headerlink" title="shred 命令 搞破坏 哈哈哈"></a>shred 命令 搞破坏 哈哈哈</h2><p>比如把你私藏的种子文件搞乱 无法恢复哦 很炫酷。。。</p>
]]></content>
    
    <summary type="html">
    
      一些好玩的linux命令
    
    </summary>
    
    
      <category term="命令" scheme="http://heweiblog.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>DNS BIND 压力测试 queryperf 使用</title>
    <link href="http://heweiblog.top/2017/09/05/DNS-BIND-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-queryperf-%E4%BD%BF%E7%94%A8/"/>
    <id>http://heweiblog.top/2017/09/05/DNS-BIND-压力测试-queryperf-使用/</id>
    <published>2017-09-05T09:36:38.000Z</published>
    <updated>2017-09-05T10:05:49.746Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>首先queryperf是bind自带的压力测试软件，使用queryperf可以对DNS服务器作请求测试，操作简单明了易上手，可以多次测试取平均值，特别说明queryperf的测试结果不一定准确，但与实际情况接近，具有一定参考价值。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>源码安装官网下载<a href="https://ftp.isc.org/isc/bind9/9.11.2/" target="_blank" rel="external">bind源码</a><br>[heweiwei@heweiwei local]$ cd /usr/local/bind-9.11.1/contrib/queryperf<br>[root@heweiwei queryperf]# ./configure<br>[root@heweiwei queryperf]# cp queryperf /usr/bin/</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>queryperf使用格式：<br>queryperf [-d datafile] [-s server_addr] [-p port] [-q num_queries]<br>-d: 后面接上一个文件，文件的内容是用户对DNS的请求，一行为一条请求，所以为了测试，我们可以在里面写上几千几万条。<br>-s: DNS服务器地址<br>-p: DNS服务器端口<br>-q: 指定查询的输出的最大数量</p>
<p>编辑一个测试文件<br>[heweiwei@heweiwei ~]$ vim test.txt<br>比如把下面内容 当然这些内容少的可怜，测试可以加入上万条记录<br>www.baidu.com   A<br>www.baidu.cn    cname<br>qq.com A<br>sohu.com A<br>python.org CNAME<br>python.org A<br>isc.org A<br>163.com A<br>163.com SOA<br>163.com MX<br>163.com ANY<br>163.com CNAME<br>csdn.net A<br>www.jd.com A<br>www.jd.com NS</p>
<p>执行<br>[heweiwei@heweiwei ~]$ queryperf -d test.txt -s 192.168.6.189</p>
<p>出现下列结果<br>DNS Query Performance Testing Tool<br>Version: $Id: queryperf.c,v 1.12 2007/09/05 07:36:04 marka Exp $</p>
<p>[Status] Processing input data<br>[Status] Sending queries (beginning with 192.168.6.189)<br>[Timeout] Query timed out: msg id 2<br>[Timeout] Query timed out: msg id 4<br>[Timeout] Query timed out: msg id 5<br>[Timeout] Query timed out: msg id 8<br>[Timeout] Query timed out: msg id 11<br>[Timeout] Query timed out: msg id 14<br>[Status] Testing complete</p>
<p>Statistics:</p>
<p>  Parse input file:     once<br>  Ended due to:         reaching end of file</p>
<p>  Queries sent:         15 queries<br>  Queries completed:    15 queries<br>  Queries lost:         0 queries<br>  Queries delayed(?):   0 queries</p>
<p>  RTT max:             1.022373 sec<br>  RTT min:              0.015800 sec<br>  RTT average:          0.135892 sec<br>  RTT std deviation:    0.313435 sec<br>  RTT out of range:     0 queries</p>
<p>  Percentage completed: 100.00%<br>  Percentage lost:        0.00%</p>
<p>  Started at:           Tue Sep  5 17:56:57 2017<br>  Finished at:          Tue Sep  5 17:57:02 2017<br>  Ran for:              5.000256 seconds</p>
<p>  Queries per second:   2.999846 qps</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、在作服务器的性能测试时，最好不要在服务器平台自身使用测试软件测试，最好换另外一台机器，这样CPU处理的结果会更准确。<br>2、测试时先预估平台会遇到的最大请求数，用这个请求数作测试，量力而为，因为如果服务器遇到大流量的DDOS，单一机器性能再好，也扛不住。<br>3、使用queryperf作性能测试时，最好测试多次，取平均值。<br>4、可以修改配置文件的部分参数测试，如，开启递归，开启查询日志等功能作测试。</p>
<h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p>本文参考<a href="http://blog.csdn.net/zhu_tianwei/article/details/45202899" target="_blank" rel="external">文章</a></p>
]]></content>
    
    <summary type="html">
    
      本文讲述了bind自带压力测试软件queryperf如何使用
    
    </summary>
    
      <category term="DNS服务" scheme="http://heweiblog.top/categories/DNS%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="DNS" scheme="http://heweiblog.top/tags/DNS/"/>
    
      <category term="BIND" scheme="http://heweiblog.top/tags/BIND/"/>
    
      <category term="queryper" scheme="http://heweiblog.top/tags/queryper/"/>
    
  </entry>
  
  <entry>
    <title>linux一些命令</title>
    <link href="http://heweiblog.top/2017/09/01/linux%E4%B9%8Bdig%E5%91%BD%E4%BB%A4/"/>
    <id>http://heweiblog.top/2017/09/01/linux之dig命令/</id>
    <published>2017-09-01T07:50:01.000Z</published>
    <updated>2017-09-01T08:04:29.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h2><pre><code>1.查看域名的A记录  dig yahoo.com
2.查看域名的ip  dig yahoo.com +short
3.查看域名的MX 记录  dig yahoo.com MX  
4.查看域名的SOA记录  dig yahoo.com SOA
5.查询域名的TTL记录  dig yahoo.com TTL
6.查看内容信息   dig yahoo.com +nocomments +noquestion +noauthority +noadditional +nostats 
7.查询所有的DNS记录类型  dig yahoo.com ANY +noall +answer 
8.DNS反向查询  dig -x 72.30.38.140 +short 
9.查询多个DNS记录   dig yahoo.com mx +noall +answer redhat.com ns +noall +answer 
10.单独查询    dig yahoo.com A/SOA/MX/NS/PTR +noall +answer    
11.查询所有    dig yahoo.com ANY +noall +answer
12.快速回答时，+short  dig www.baidu.com AAAA +shor
13. +multiline选项获得冗长的多行模式人性化注释的DSN的SOA记录，
    一般来说，用+multiline选项获得的信息可以显示很多，就像BIND配置文件一样
     dig +nocmd baidu.com any +multiline +noall +answer
14.跟踪dig的查询路径    dig v.qq.com +trace
</code></pre><p> 15.dig qq.com @x.x.x.x</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><pre><code>Linux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件
find pathname -options [-print -exec -ok ...]        用于在文件树种查找文件，并作出相应的处理 
find -atime -2     超找48小时内修改过的文件
find . -name &quot;*.log&quot;    在当前目录查找 以.log结尾的文件。 &quot;. &quot;代表当前目录     
find /opt/soft/test/ -perm 777    查找/opt/soft/test/目录下 权限为 777的文件
find . -type f -name &quot;*.log&quot;    查找当目录，以.log结尾的普通文件 
find . -type d | sort    查找当前所有目录并排序
find . -size +1000c -print    查找当前目录大于1K的文件 
ubantu 用于16.04以上版本
</code></pre><h2 id="ubantu-界面设置"><a href="#ubantu-界面设置" class="headerlink" title="ubantu 界面设置"></a>ubantu 界面设置</h2><pre><code>gsettings set com.canonical.Unity.Launcher launcher-position Bottom     移动到下方
gsettings set com.canonical.Unity.Launcher launcher-position Left    移动到左方
</code></pre><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><pre><code>vim打开一个文件 shift + ： 使用 vsplit 命令再打开一个文件    vsplit + 文件 
q qall（关闭所有） only（关闭当前）
在一般模式下输入“:new /root/2.txt” 新编辑文件2.txt
ctrl + ww 切换 

把正在编辑的文件另存为
在一般模式下输入“:w /root/1.txt”

正在编辑文件时，不退出文件仍可以运行linux命令
eg：在编辑模式下输入“:! cat /root/1.txt”

.查找替换的功能使用
例：在10到15行的行首增加“#”
在一般模式下输入“:10,15s/^/#/”
例：在10到15行的行首去掉“#”
在一般模式下输入“:10,15s/^#//”
例：在10到15行的行首增加“//”
在一般模式下输入“:10,15s/^/\/\//”或者“:10,15s@^@//@”或者“:10,15s#^#//#”

把文件恢复到打开时的状态
在一般模式下输入“:e!

vim 中 shift + 3 选中单词 可以突出显示这个单词全部

ctrl +n 自动补全 ctrl + p 也一样

删除空行：:%s/^\n$//g

自动对齐 v 进入可视模式后选中要对齐的部分 = 号自动对齐

stat 文件   获取文件详细信息
fdisk -l 查看磁盘信息

vim 用swap 文件恢复未保存的文件
vim -r filename 后 删除 swap文件
vimdiff 
比较两个文件不同
vimdiff /home/heweiwei/dial_cpp/Makefile Makefile.jc
或者使用diff命令重定向也可以达到比较效果
diff /home/heweiwei/dial_cpp/Makefile Makefile.jc &gt; cmp.txt
</code></pre><h2 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h2><pre><code>查找指定进程
ps -ef|grep svn
ps -aux|grep svn
ps -ef|grep svn -c    包含个数
ps -ef|grep -c svn    

输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行
cat test.txt | grep -f test2.txt
cat test.txt | grep -nf test2.txt

从文件中查找关键字    
grep &apos;linux&apos; test.txt
grep &apos;linux&apos; test.txt test2.txt

grep不显示本身进程
ps aux|grep \[s]sh
ps aux | grep ssh | grep -v &quot;grep&quot;

找出以 u 开头的行内容
cat test.txt |grep ^u
找出非 u 开头的行内容
cat test.txt |grep ^[^u]

输出以hat结尾的行内容
cat test.txt |grep hat$

显示包含ed或者at字符的内容行
cat test.txt |grep -E &quot;ed|at&quot;

显示当前目录下面以.txt 结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行
grep &apos;[a-z]\{7\}&apos; *.txt
</code></pre><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><pre><code>把本地文件或目录拷到目标机指定目录

对拷文件夹 (包括文件夹本身)
scp -r   /home/wwwroot/www/charts/util root@192.168.1.65:/home/wwwroot/limesurvey_back/scp
/home/wwwroot/www/charts/util    本地文件目录
root@192.168.1.65:/home/wwwroot/limesurvey_back/scp    目标ip及目录

对拷文件夹下所有文件 (不包括文件夹本身)
scp   /home/wwwroot/www/charts/util/* root@192.168.1.65:/home/wwwroot/limesurvey_back/scp

 对拷文件并重命名
scp   /home/wwwroot/www/charts/util/a.txt root@192.168.1.65:/home/wwwroot/limesurvey_back/scp/b.text

把目标机文件或者目录拷贝到本地指定目录
scp -r root@192.168.6.240:/home/heweiwei/studytest /home/heweiwei/
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;dig&quot;&gt;&lt;a href=&quot;#dig&quot; class=&quot;headerlink&quot; title=&quot;dig&quot;&gt;&lt;/a&gt;dig&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1.查看域名的A记录  dig yahoo.com
2.查看域名的ip  dig yahoo.com +short

    
    </summary>
    
      <category term="linux命令" scheme="http://heweiblog.top/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="命令" scheme="http://heweiblog.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>C语言面试</title>
    <link href="http://heweiblog.top/2017/09/01/C%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95/"/>
    <id>http://heweiblog.top/2017/09/01/C语言面试/</id>
    <published>2017-09-01T07:02:33.000Z</published>
    <updated>2017-09-01T08:06:48.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>曾经面试做过的一些面试题目</p>
<h2 id="C-C-题目："><a href="#C-C-题目：" class="headerlink" title="C/C++题目："></a>C/C++题目：</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h3><p>比较字符串<br>输出它们第一个不同字母的位置，大小写不敏感  // if(str1[i] == (str2[i] | 0x20))<br>int cmpstr(const char<em> str1,const char</em> str2)<br>{<br>    int i = 0;</p>
<pre><code>while(str1[i] != &apos;\0&apos; &amp;&amp; str2[i] != &apos;\0&apos;)
{
    if(str1[i] == (str2[i] | 0x20))
{
    i++;
    continue;
}
return i+1;
}
return 0;
</code></pre><p>}</p>
<h3 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h3><p>判断一个数是不是回文数，数字 1234321。<br>int judge(int num)<br>{<br>    int temp1 = 0,temp2 = 0,temp3 = num;</p>
<pre><code>while(num)
{
    temp1 = num % 10;
temp2 = temp2 * 10 + temp1;
num = num / 10;
}
if(temp2 == temp3)
{
    return 1;
}
return 0;
</code></pre><p>}</p>
<h3 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h3><p>比较两字符串长短，并返回结果。<br>int cmpstr(const char<em> str1,const char</em> str2)<br>{<br>    int i = 0,j = 0;</p>
<pre><code>while(str1[i])
{
    i++;
}

while(str2[j])
{
    j++;
}

return i - j;
</code></pre><p>} </p>
<h3 id="4、给一个字符串，编程取其中一个特定的字符并输出，返回值-int-char-字符的偏移量-或-地址"><a href="#4、给一个字符串，编程取其中一个特定的字符并输出，返回值-int-char-字符的偏移量-或-地址" class="headerlink" title="4、给一个字符串，编程取其中一个特定的字符并输出，返回值 int / char* 字符的偏移量 或 地址"></a>4、给一个字符串，编程取其中一个特定的字符并输出，返回值 int / char* 字符的偏移量 或 地址</h3><p>int findch(const char* str,char ch)<br>{<br>    int i = 0;</p>
<pre><code>while(str[i])
{
    if(ch == str[i])
{
    return i+1;
}
i++;
}
return 0;
</code></pre><p>} </p>
<h3 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h3><p>是比较两个英文字符串的不相同的字符的位置（忽略字母大小写）<br>int cmpstr(const char<em> str1,const char</em> str2,int site[])<br>{<br>    int i = 0,j = 0;</p>
<pre><code>while(str1[i] != &apos;\0&apos; &amp;&amp; str2[i] != &apos;\0&apos;)
{
    if(str1[i] == (str2[i] | 0x20))
{
    i++;
    continue;
}
site[j] = i + 1;
j++;
i++;
}

return j;
</code></pre><p>}</p>
<h3 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h3><p>主函数调用一函数<br>如：检索出字符串中出现次数最多的那个字符，不考虑大小写，然后返回该字符。<br>char findch(const char* str)<br>{<br>    int i = 0,j = 0,ct1 = 0,ct2 = 0;<br>    char ch1 = ‘\0’,ch2 = ‘\0’;</p>
<pre><code>while(str[i])
{
    j = 0;
ct1 = 0;        //这两个条件不可忽略
    while(str[j++])
{
    if(str[i] == str[j])
    {
        ct1++;
    ch1 = str[i];
    }
}
if(ct2 &lt; ct1)
{
    ct2 = ct1;
    ch2 = ch1;
}
i++;
}
return ch2;
</code></pre><p>}</p>
<h3 id="7、"><a href="#7、" class="headerlink" title="7、"></a>7、</h3><p>查找字符串中出现次数最多的字符<br>并返回该字符，只考虑小写字母，不考虑不同字母出现次数一样多的情况<br>char findch(const char* str)<br>{<br>    int i = 0,j = 0,ct1 = 0,ct2 = 0;<br>    char ch1 = ‘\0’,ch2 = ‘\0’;</p>
<pre><code>while(str[i])
{
    if(str[i] &lt; &apos;a&apos; || str[i] &gt; &apos;z&apos;)
{
    i++;
    continue;
}

    j = 0;
ct1 = 0;        //这两个条件不可忽略

    while(str[j++])
{
    if(str[i] == str[j])
    {
        ct1++;
    ch1 = str[i];
    }
}
if(ct2 &lt; ct1)
{
    ct2 = ct1;
    ch2 = ch1;
}
i++;
}
return ch2;
</code></pre><p>}</p>
<h3 id="8、"><a href="#8、" class="headerlink" title="8、"></a>8、</h3><p>输入一个整数n，计算不大于n的数中和7相关的数的个数，<br>包括能被7整出的数和含有字符7的数，例如：输入20，输出3（7、14、17）。<br>int ctseven(int num)<br>{<br>    int ct = 0,i = 0,temp1 = 0,temp2 = 0;</p>
<pre><code>if(num &lt; 7)
{
    return 0;
}

for(i = 7;i &lt; num;i++)
{
    if(i % 7 == 0)
{
    ct++;
    continue;
}

temp2 = i;

    while(temp2)
{
    temp1 = temp2 % 10;
    if(7 == temp1)
    {
        ct++;
        break;
    }
    temp2 = temp2 / 10;
}
}
return ct;
</code></pre><p>}</p>
<h3 id="9、"><a href="#9、" class="headerlink" title="9、"></a>9、</h3><p>输入一个整数将每一位上的奇数放在一个新整数中，高位放在高位，地位在低位。<br>int getnum(int num)<br>{<br>    int i = 1,newnum = 0,temp = 0;    </p>
<pre><code>while(num)
{
    temp = num % 10;
if(temp % 2 != 0)
{
    newnum = newnum + temp * i;
    i *= 10;
}
num = num / 10;
}
return newnum;
</code></pre><p>}</p>
<h3 id="10、"><a href="#10、" class="headerlink" title="10、"></a>10、</h3><p>输入一串数，<br>将其最小的放在第一位，次小的放在最后一位，<br>再小的放在第二位，再再小的放在倒数第二位，以此类推。<br>void get_newnum(int num[],int n)<br>{<br>    int i = 0,j = 0,k = 0,t = 0,temp = 0;    // t k 两个变量均用于控制数组下标</p>
<pre><code>for(i = 0;i &lt; n-1-k;i++)
{
    for(j = i;j &lt; n-1-k;j++)
{
    if(num[i] &gt; num[j+1])
    {
        temp = num[i];
    num[i] = num[j+1];
    num[j+1] = temp;
    }
}
t++;            //算法实现 k控制循环范围 t控制循环数组元素交换    
if(t % 2 == 0)
{
    temp = num[i];
    num[i] = num[n-i];
    num[n-i] = temp;
    i--;
    k++;
}
}
</code></pre><p>}</p>
<h3 id="11、"><a href="#11、" class="headerlink" title="11、"></a>11、</h3><p>写一个函数，传入参数为应付钱数。<br>返回值为买家最少付出的钱的张数int get MoneyNum(int  iInputMoney)例如：买家应付351元，<br>最少张数为5.备注：可支付的钱币只有100、50、10、5、1不考虑2、20以及小数部分。<br>int getct_money(int money)<br>{<br>    int ct = 0;</p>
<pre><code>ct += money / 100;
money %= 100;
ct += money / 50;
money %= 50;
ct += money / 20;
money %= 20;
ct += money / 10;
money %= 10;
ct += money / 5;
money %= 5;
ct += money / 1;
money %= 1;

return ct;
</code></pre><p>}</p>
<h3 id="12、"><a href="#12、" class="headerlink" title="12、"></a>12、</h3><p>设有几个人围坐在一圈并按顺时针方向从1到几编号，从第S个人开始进行1到m的报数。报数到第M个人，此人出圈。再从他的下一个人重新开始1到M的报数，如此进行下一直到所有人都出圈为止，输出报数顺序。<br>void getrank(int num[],int n,int num1,int num2,int newnum[])<br>{<br>    struct rank<br>    {<br>        int number;<br>    struct rank<em> next;<br>    };<br>    int i = 0,j = 0;<br>    struct rank</em> p = NULL;<br>    struct rank<em> temp1 = NULL;<br>    struct rank</em> temp2 = NULL;<br>    struct rank* phead = NULL;</p>
<pre><code>phead = p = calloc(1,sizeof(struct rank));
p-&gt;number = num[0];

for(i = 1;i &lt; n;i++)
{
    p-&gt;next = calloc(1,sizeof(struct rank));
    p-&gt;next-&gt;number = num[i];
p = p-&gt;next;
}

p-&gt;next = phead;            //形成一个环形链表

while(phead-&gt;number != num1)    //找出从谁开始报数
{
phead = phead-&gt;next;
}

for(j = 0;j &lt; n;j++)            
{
    for(i = 0;i &lt; num2-1;i++)    //报数到num2时跳出循环 phead指向的number就是要出圈的数字
    {
    temp1 = phead;
    phead = phead-&gt;next;
    }
newnum[j] = phead-&gt;number;
temp2 = phead;
phead = phead-&gt;next;
free(temp2);            //出圈后删除该节点
temp1-&gt;next = phead;     
}
</code></pre><p>}</p>
<h3 id="13、"><a href="#13、" class="headerlink" title="13、"></a>13、</h3><p>对姓氏进行排名<br>Char str[ ]=”zhang   wang   li    zhao”<br>Char str_ new[ ]=”li  wang   zhang   zhao”<br>void getstr(char str1[],int n,char str2[])<br>{<br>    int i = 0,j = 0,k = 0;    //i j k 均用于数组下标<br>    int len = strlen(str1);<br>    char<em> str[n];<br>    char</em> temp = NULL;</p>
<pre><code>for(i = 0;i &lt; n;i++)
{
    str[i] = calloc(1,len);
}

i = 0;        //while 一定要初始化
while(str1[i])    //str[i++] 不可这样写
{
    if(str1[i] == &apos; &apos;)
{
    k = 0;
    j++;
    i++;    //while continue前 i++    
    continue;
}
str[j][k] = str1[i];
i++;
k++;
}

for(i = 0;i &lt; n-1;i++)
{
    for(j = i;j &lt; n-1;j++)
{
    if(strcmp(str[i],str[j+1]) &gt; 0)
    {
        temp = str[i];
    str[i] = str[j+1];
    str[j+1] = temp;
    }
}
}

strcpy(str2,str[0]);

for(i = 1;i &lt; n;i++)
{
    strcat(str2,&quot; &quot;);
    strcat(str2,str[i]);
}

for(i = 0;i &lt; n;i++)
{
    free(str[i]);
}
</code></pre><p>}</p>
<h3 id="14、"><a href="#14、" class="headerlink" title="14、"></a>14、</h3><p>将一组整数中为奇数的数提取出来，高低位顺序不变。如：8 3 7 9 5 2 1 4—–》3 7 5 1<br>int getodd(int num1[],int n,int num2[])<br>{<br>    int i = 0,j = 0;</p>
<pre><code>for(i = 0;i &lt; n;i++)
{
    if(num1[i] % 2 != 0)
{
    num2[j] = num1[i];
    j++;
}
}
return j;
</code></pre><p>}</p>
<h3 id="15、"><a href="#15、" class="headerlink" title="15、"></a>15、</h3><p>一组2n+1个元素的正整形数组，按升序排序，然后将小于中间数值的成员替换为中间的值。（貌似还有：“位置不变”，不过实在不理解其含义，看了例子就不用关心它的意思了），例如：1,2,3,4,5，输出为：3,3,3,4,5，原型：int fun(int arry[],int n,char<em>output){return 0;}<br>int fun(int num[],int n,char</em> output)<br>{<br>    int i = 0,j = 0,temp = 0;</p>
<pre><code>for(i = 0;i &lt; n-1;i++)
{
    for(j = i;j &lt; n-1;j++)
{
    if(num[i] &gt; num[j+1])
    {
        temp = num[i];
    num[i] = num[j+1];
    num[j+1] = temp;
    }
}
}

j = n / 2;

for(i = 0;i &lt; j;i++)
{
    num[i] = num[j];
}

for(i = 0;i &lt; n;i++)
{
    output[i] = num[i] + &apos;0&apos;;
}

return num[j];
</code></pre><p>}</p>
<h3 id="16、"><a href="#16、" class="headerlink" title="16、"></a>16、</h3><p>输入一个四位的十进制整数，编程实现将这四位整数转化为十六进制的字符串，并输出十六进制的字符串（注意负数的处理）<br>int hex_to_str(int num,char str[])<br>{<br>    int i = 0,len = 0,temp = 0;<br>    char ch = ‘\0’;</p>
<pre><code>while(num)
{
temp = num &amp; 0xf;

    if(temp &lt; 10)
{
    str[i] = &apos;0&apos; + temp;
}
else
{
    str[i] = &apos;a&apos; + temp - 10;
} 

num = num &gt;&gt; 4;

if(num &lt; 0)
{
    num = num &amp; 0xfffffff;
}
i++;
}

str[i] = &apos;\0&apos;;
len = strlen(str);

for(i = 0;i &lt; len / 2;i++)
{
    ch = str[i];
str[i] = str[len-1-i];
str[len-1-i] = ch;
}

return len;
</code></pre><p>}</p>
<h3 id="17、输入：一个四位的整数，比如：2367，输出：2-3-6-7-18"><a href="#17、输入：一个四位的整数，比如：2367，输出：2-3-6-7-18" class="headerlink" title="17、输入：一个四位的整数，比如：2367，输出：2+3+6+7=18"></a>17、输入：一个四位的整数，比如：2367，输出：2+3+6+7=18</h3><p>int int_to_str(int num,char str[])<br>{<br>    int i = 0,j = 0,k = 0,temp = num,sum = 0;</p>
<pre><code>while(temp)
{
    temp /= 10;
i++;
}

int* pnum = calloc(i+1,sizeof(int));
for(j = i-1;j &gt;= 0;j--)
{
    pnum[j] = num % 10;
sum += pnum[j];
num = num / 10;
}
pnum[i] = sum;

for(j = 0;j &lt; i*2;j++)
{
    if(j % 2 == 0)
{
        str[j] = pnum[k] + &apos;0&apos;;
    k++;
    continue;
} 
str[j] = &apos;+&apos;;
}

j--;
str[j] = &apos;=&apos;;

if(sum / 10)
{
    str[j+1] = sum / 10 + &apos;0&apos;;        
    str[j+2] = sum % 10 + &apos;0&apos;;
str[j+3] = &apos;\0&apos;
free(pnum);
return j+3;
}

str[j+1] = &apos;0&apos; + sum % 10;
str[j+2] = &apos;\0&apos;
free(pnum);
return j+2;
</code></pre><p>}</p>
<h3 id="18-将一个正整数转换为字符串"><a href="#18-将一个正整数转换为字符串" class="headerlink" title="18,将一个正整数转换为字符串"></a>18,将一个正整数转换为字符串</h3><p>char<em> int_to_str(int num,char</em> str)<br>{<br>    int i = 0,j = 0,temp1 = 0,temp2 = num;</p>
<pre><code>while(num)
{
    temp1 = num % 10;          
    num = num / 10;
j++;
}
str[j] = &apos;\0&apos;;
for(i = j-1;i &gt;= 0;i--)
{
temp1 = temp2 % 10;
str[i] = &apos;0&apos; + temp1;
temp2 = temp2 / 10;
}
return str;
</code></pre><p>}</p>
<h3 id="19，"><a href="#19，" class="headerlink" title="19，"></a>19，</h3><p>将一个字符串转换为正整数<br>int str_to_int(const char* str)<br>{<br>    int i = 0,sum = 0;</p>
<pre><code>while(str[i])
{
    sum = sum * 10 + (str[i] - &apos;0&apos;);
i++;
}
return sum;
</code></pre><p>}</p>
<h3 id="20-从长串中找到连续相同字符最长的字串"><a href="#20-从长串中找到连续相同字符最长的字串" class="headerlink" title="20,从长串中找到连续相同字符最长的字串"></a>20,从长串中找到连续相同字符最长的字串</h3><p>int get_childstr(const char<em> str,char</em> childstr)<br>{<br>    int i = 0,ct1 = 0,ct2 = 0;<br>    char ch = ‘\0’;</p>
<pre><code>while(str[i])
{
    ct1 = &apos;\0&apos;;            // 要比较 切莫忘记初始化比较量
    while(str[i] == str[i+1])
{
    ct1++;
    i++;
}
if(ct2 &lt; ct1)
{
    ct2 = ct1;
    ch = str[i];
}
i++;
}
for(i = 0;i &lt; ct2+1;i++)
{
    childstr[i] = ch;
}
childstr[i] = &apos;\0&apos;;

return ct2+1;
</code></pre><p>}</p>
<h3 id="21"><a href="#21" class="headerlink" title="21,"></a>21,</h3><p>将一个字符串逆序<br>char* getstr(char str[])<br>{<br>    int i = 0;<br>    int len = strlen(str);<br>    char ch = ‘\0’;</p>
<pre><code>for(i = 0;i &lt; len / 2;i++)
{
ch = str[i];
str[i] = str[len-i-1];
str[len-i-1] = ch;
}
return str;
</code></pre><p>}</p>
<h3 id="22"><a href="#22" class="headerlink" title="22,"></a>22,</h3><p>搜索给定的字节<br>void<em> findbyte(const void</em> st,size_t len,char dat)<br>{<br>    int i = 0;<br>    char<em> str = (char</em>)st;</p>
<pre><code>while(str[i])
{
if(dat == str[i])
{
    return str + i;
}
i++;
}

return NULL;
</code></pre><p>}</p>
<h3 id="23-将一个链表逆序"><a href="#23-将一个链表逆序" class="headerlink" title="23,将一个链表逆序"></a>23,将一个链表逆序</h3><p>void oppsite_list(ST<em> head)<br>{<br>    ST</em> phead = NULL;<br>    ST* P = head;<br>    head = head-&gt;next;<br>    p-&gt;next = NULL;</p>
<pre><code>while(head)        //    循环结束后 p 变为头指针
{
    phead = head-&gt;next
head-&gt;next = p;
p = head;        
head = phead;
}
</code></pre><p>}</p>
<h3 id="24"><a href="#24" class="headerlink" title="24,"></a>24,</h3><p>判断一个字节有多少个1<br>int getsize(char ch)<br>{<br>    int i = 8,temp = 0,ct = 0;<br>    while(i–)<br>    {<br>    temp = ch &amp; 1;<br>    if(temp)<br>    {<br>        ct++;<br>    }<br>    ch &gt;&gt;= 1;<br>    }<br>    return ct;<br>}</p>
<h3 id="24-1"><a href="#24-1" class="headerlink" title="24,"></a>24,</h3><p>直接插入排序 冒泡排序 选择排序<br>void rank(int num[],int n)    // 直接插入<br>{<br>    int i = 0,j = 0,temp = 0;</p>
<pre><code>for(i = 1;i &lt; n;i++)
{
    temp = num[i];
for(j = i - 1;j &gt;= 0 &amp;&amp; temp &lt; num[j];j--)    // temp&lt;num[j]从小到大  temp&gt;num[j]从大到小 
{
    num[j+1] = num[j];
}
num[j+1] = temp;
}
</code></pre><p>}</p>
<p>void rank(int num[],int n)    // 冒泡<br>{<br>    int i = 0,j = 0,temp = 0;</p>
<pre><code>for(i = 0;i &lt; n;i++)
{
for(j = n - 1;j &gt;= i;j--)     
{
    if(num[j+1] &lt; num[j])
    {
    temp = num[j+1];
    num[j+1] = num[j];
    num[i] = temp;
    }
}
}
</code></pre><p>}</p>
<p>void myrank_min(int num[],int count)    // 冒泡<br>{<br>    int i = 0,j = 0,temp = 0;</p>
<pre><code>for(i = 0;i &lt; count-1;i++)
{
for(j = i;j &lt; count-1;j++)
{
    if(num[i] &gt; num[j+1])
    {
        temp = num[i];
    num[i] = num[j+1];
    num[j+1] = temp;
    }
}
}
</code></pre><p>}</p>
<p>void rank(int num[],int n)    // 选择<br>{<br>    int i = 0,j = 0,k = 0,temp = 0;</p>
<pre><code>for(i = 0;i &lt; n;i++)
{
temp = num[i];
k = i;
for(j = i;j &lt; n;j++)     
{
    if(temp &gt; num[j])
    {
    temp = num[j];
    k = j;
    }
}
num[k] = num[i];
num[i] = temp;
}
</code></pre><p>}</p>
<h3 id="26"><a href="#26" class="headerlink" title="26,"></a>26,</h3><p>判断一个字符串有多少个单词<br>int getsize(const char* str)<br>{<br>    int state = 0,i = 0,ct = 0;</p>
<pre><code>while(str[i])
{
if(str[i] == &apos; &apos;)
{
    state = 1;
    i++;
    continue;
}
if(state)
{
    state = 0;
    ct++;
}
}
return ct+1;
</code></pre><p>}</p>
<p>###26,<br>实现strcmp<br>int strcmp(onst char<em> s1,const char</em> s2)<br>{<br>    int i = 0;</p>
<pre><code>while(s1[i] != &apos;\0&apos; &amp;&amp; s2[i] != &apos;\0&apos;)
{
    if(s1[i] == s2[i])
{
    i++;
    continue;
}
return s1[i] - s2[i];
}
if(strlen(s1) == strlen(s2))
{
return 0;
}
return strlen(s1) - strlen(s2);
</code></pre><p>}</p>
<p>int strcmp(onst char<em> s1,const char</em> s2)<br>{<br>    int i = 0;</p>
<pre><code>while(s1[i] != &apos;\0&apos; &amp;&amp; s2[i] != &apos;\0&apos;)
{
    if(s1[i] == s2[i])
{
    i++;
    continue;
}
return s1[i] - s2[i];
}
if(s1[i] == &apos;\0&apos;)
{
return -1;
}
if(s2[i] == &apos;\0&apos;)
{
    return 1;
}
return 0;
</code></pre><p>}</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面试还是看基础</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;曾经面试做过的一些面试题目&lt;/p&gt;
&lt;h2 id=&quot;C-C-题目：&quot;&gt;&lt;a href=&quot;#C-C-题目：&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="C语言" scheme="http://heweiblog.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C面试" scheme="http://heweiblog.top/tags/C%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>有趣的C语言小测试</title>
    <link href="http://heweiblog.top/2017/09/01/%E6%9C%89%E8%B6%A3%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%B5%8B%E8%AF%95/"/>
    <id>http://heweiblog.top/2017/09/01/有趣的C语言小测试/</id>
    <published>2017-09-01T06:07:31.000Z</published>
    <updated>2017-09-01T06:42:58.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>C语言是其他语言拓展的基石，如对库的支撑，C语言暂时不敢变，变了岂不好多人要失业，高级语言可以玩出很多变化，但是偏底层靠的是基础，俗话说万变不离其宗，基础扎实才是拓展的前提。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>下面各个题目输出是什么呢？32位操作系统</p>
<h3 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h3><p>unsigned int a = 6;<br>int b = -20;<br>(a+b &gt; 0)? puts(“why”) : puts(“I don‘t no”);</p>
<h3 id="测试二"><a href="#测试二" class="headerlink" title="测试二"></a>测试二</h3><p>int ar[] ={6,7,8,9,10};<br>int <em>ptr=ar;
</em>(ptr++)+=123;<br>printf(“%d,%d \n”,<em>ptr,</em>(++ptr));<br>printf(“%d%d%d\n”,ar[0],ar[1],ar[2]);</p>
<h3 id="测试三"><a href="#测试三" class="headerlink" title="测试三"></a>测试三</h3><p>int a[3] = {1,11,22};<br>int <em>p = a;<br>printf(“</em>p++ = %d\n”,<em>p++);<br>printf(“</em>++p = %d\n”,*++p);</p>
<h3 id="测试四"><a href="#测试四" class="headerlink" title="测试四"></a>测试四</h3><p>int a[5] = { 1 , 2 , 3 , 4 , 5 };<br>int <em>ptr = (int </em>)( (char<em>) a + 1 );<br>printf(“%#x\n”,</em>ptr);    </p>
<h3 id="测试五"><a href="#测试五" class="headerlink" title="测试五"></a>测试五</h3><p>求一个字符串长度，不要用库函数，不要用中间变量</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="测试一-1"><a href="#测试一-1" class="headerlink" title="测试一"></a>测试一</h3><p>无符号整型问题的答案是输出是“why”。<br>原因是当表达式中存在有符号<br>类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大<br>的正整数，所以该表达式计算出的结果大于0。</p>
<h3 id="测试二-1"><a href="#测试二-1" class="headerlink" title="测试二"></a>测试二</h3><p>输出依次是 8  8  129  7  8<br>拆开后看是这样的<br><em>ptr += 123；<br>ptr++；<br>++ptr；<br>printf(“%d,%d \n”,</em>ptr,*ptr);<br>printf(“%d%d%d\n”,ar[0],ar[1],ar[2]);</p>
<h3 id="测试三-1"><a href="#测试三-1" class="headerlink" title="测试三"></a>测试三</h3><p>输出为1 22<br>计算顺序<br>printf(“<em>p++ = %d\n”,</em>p);<br>p++;<br>++p;<br>printf(“<em>++p = %d\n”,</em>p);</p>
<h3 id="测试四-1"><a href="#测试四-1" class="headerlink" title="测试四"></a>测试四</h3><p>结果 0x2000000<br>数据在内存的储存形式</p>
<h3 id="测试五-1"><a href="#测试五-1" class="headerlink" title="测试五"></a>测试五</h3><p>可以用递归<br>int getlen(char<em>s)<br>{<br>    if(</em>s == ‘\0’)<br>        return 0;<br>    s++;<br>    return getlen(s) + 1;<br>}</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不要小看一些细小的额东西，有些错误很难发现有可能就是因为这些越细小的基础造成的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;C语言是其他语言拓展的基石，如对库的支撑，C语言暂时不敢变，变了岂不好多人要失业，高级语言可以玩出很多变化，但是偏底层靠的是基础，俗话说万变
    
    </summary>
    
      <category term="C语言" scheme="http://heweiblog.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C基础" scheme="http://heweiblog.top/tags/C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>git远程仓库关联</title>
    <link href="http://heweiblog.top/2017/09/01/git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94/"/>
    <id>http://heweiblog.top/2017/09/01/git远程仓库关联/</id>
    <published>2017-09-01T04:51:18.000Z</published>
    <updated>2017-09-01T05:50:01.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我的环境：ubantu17.04 其他linux发行版本安装使用大同小异<br>安装git：sudo apt-get install git<br>首先必须有一个githup账号 去官网注册即可 同时绑定邮箱<br>有了账号后创建远程仓库 比如我创建的仓库名字为project</p>
<h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>本地创建密钥命令如下<br>ssh-keygen -t rsa -C “邮箱地址”<br>公钥存放在用户主目录 ~/.ssh/id_rsa.pub<br>复制到官网在账户设置一栏添加即可</p>
<h2 id="验证连接"><a href="#验证连接" class="headerlink" title="验证连接"></a>验证连接</h2><p>验证是否能连接上<br>ssh -T git@github.com<br>输入yes后出现类似以下内容表示已经可以连接<br>Hi he475943497! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<h2 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h2><p>执行下列命令<br>创建仓库并初始化<br>mkdir project<br>cd project<br>git init</p>
<h2 id="指明用户"><a href="#指明用户" class="headerlink" title="指明用户"></a>指明用户</h2><p>若之前没有使用git执行以下操作<br>git config –global user.email “邮箱地址”<br>git config –global user.name “用户名”</p>
<h2 id="本地与远程关联并推送"><a href="#本地与远程关联并推送" class="headerlink" title="本地与远程关联并推送"></a>本地与远程关联并推送</h2><p>touch test.txt<br>git add test.txt<br>git commit -m “test”<br>git remote add origin git@github.com:用户名/仓库名.git<br>推送到远程<br>git push -u origin master 第一次提交加-u参数<br>之后提交<br>git add .  git commit -m “test”   git push 即可</p>
<h2 id="git教程"><a href="#git教程" class="headerlink" title="git教程"></a>git教程</h2><p>git作为目前最流行的版本管理工具，我觉得很有学习的必要<br>有兴趣的同学可以参考：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰git教程</a><br>作者写的很幽默通俗易懂</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我的环境：ubantu17.04 其他linux发行版本安装使用大同小异&lt;br&gt;安装git：sudo apt-get install git
    
    </summary>
    
      <category term="开发工具" scheme="http://heweiblog.top/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://heweiblog.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>你好世界</title>
    <link href="http://heweiblog.top/2017/08/31/hello-world/"/>
    <id>http://heweiblog.top/2017/08/31/hello-world/</id>
    <published>2017-08-31T09:36:50.874Z</published>
    <updated>2017-08-31T09:36:50.874Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来的 <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a> 的世界! 这是你的第一个帖子.仔细检查一下 <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> 更多信息。如果你在使用Hexo上遇到任何问题，你可以找到答案 <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> 或者你可以询问 <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建第一个帖子"><a href="#创建第一个帖子" class="headerlink" title="创建第一个帖子"></a>创建第一个帖子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>更多信息: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎来的 &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt; 的世界! 这是你的第一个帖子.仔细检查一下 &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; 更多信息。如果你在使用Hexo上遇到任何问题，你可以找到答案 &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; 或者你可以询问 &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="http://heweiblog.top/2017/08/31/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://heweiblog.top/2017/08/31/hexo搭建个人博客/</id>
    <published>2017-08-31T02:46:56.000Z</published>
    <updated>2017-09-01T05:46:18.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>想拥有一个个人博客，利用hexo可以满足基本需求，博客应有的基本功能都可以实现</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>ubantu mac windows 均可</p>
<h2 id="必备"><a href="#必备" class="headerlink" title="必备"></a>必备</h2><p>git  nodejs  npm  nvm  具体怎么安装百度一下即可方法很多</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>所关联github上个人仓库必须和用户名相同 如用户名为heweiwei 则仓库名应该为heweiwei.github.io</p>
<h2 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h2><p>解决 vimrc添加一下内容<br>set fileencodings=utf-8,gb2312,gbk,gb18030<br>set termencoding=utf-8<br>set encoding=prc</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>前面各个必备软件安装正常<br>执行 npm install -g hexo-cli </p>
<h3 id="推送到远程"><a href="#推送到远程" class="headerlink" title="推送到远程"></a>推送到远程</h3><p>hexo init hexoweb<br>cd hexoweb/<br>npm install<br>hexo clean<br>hexo new your post name<br>hexo generate<br>hexo deploy<br>当然这样做之后访问的页面很简单具体修改参见:<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo官方文档</a></p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>浏览器输入yourname.github.io即可访问<br>也可以去域名服务商买一个域名<br>价格不等我买的.top顶级域第一年8块大洋</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>我用的是next主题简单大体参照<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="external">next官方使用文档</a>就够了<br>更换背景：<br>找一个背景图片放到 hexo（hexo工程文件）themes/next/source/images 下<br>修改themes/next/source/css/_custom/custom.styl文件<br>在文件加上一代码<br> body { background:url(/images/yourbackGround.jpg);} </p>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>外观设计基本搞定之后剩下的就是苦力活了<br>参照<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">hexo官方文档</a>基本都能搞定</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;想拥有一个个人博客，利用hexo可以满足基本需求，博客应有的基本功能都可以实现&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; 
    
    </summary>
    
      <category term="搭建博客" scheme="http://heweiblog.top/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://heweiblog.top/tags/hexo/"/>
    
      <category term="博客" scheme="http://heweiblog.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
